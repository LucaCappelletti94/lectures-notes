\providecommand{\main}{..}
\documentclass[\main/main.tex]{subfiles}
\begin{document}

\chapter{Complessità computazionale}

\section{Complessità temporale}
La complessità asintotica di un algoritmo nel caso pessimo fornisce una misura del tempo di calcolo dell'algoritmo attraverso i seguenti passaggi:
\begin{enumerate}
  \item Misuriamo il tempo col numero \(T\) di operazioni elementari eseguite.
  \item Scegliamo un valore \(n\) che misuri la dimensione di un'istanza.
  \item Troviamo il tempo di calcolo massimo per le istanze di dimensione \(n\), denominato con \(T(n)\).
  \item Approssimiamo \(T(n)\) con una funzione \(f(n)\) più semplice, di cui interessa solo l'andamento per \(n\rightarrow + \infty \).
  \item Raccogliamo le funzioni in classi con la stessa approssimante.
\end{enumerate}

\subsection{Notazione Theta grande}
Con la notazione \(T(n) \in \Theta(f(n)) \) si indica che \(f(n)\) stima \(T(n)\) a meno di un fattore moltiplicativo:
\[
  \exists c_1, c_2 \in \R^+, n_0 \in \N: c_1 \cdot f(n) \leq T(n) \leq c_2 \cdot f(n) \quad \forall n \geq n_0
\]
dove \(c_1\), \(c_2\) e \(n_0\) sono dipendenti da \(n\).

\subsection{Notazione O grande}
Con la notazione \(T(n) \in O(f(n))\) si indica che \(f(n)\) stima \(T(n)\) per eccesso a meno di un fattore moltiplicativo:
\[
  \exists c \in \R^+, n_0 \in \N: T(n) \leq c\cdot f(n) \quad \forall n \geq n_0
\]
dove \(c\) e \(n_0\) sono indipendenti da \(n\).

\subsection{Notazione Omega grande}
Con la notazione \(T(n) \in \Omega(f(n))\) si indica che \(f(n)\) stima \(T(n)\) per difetto a meno di un fattore moltiplicativo:
\[
  \exists c \in \R^+, n_0 \in \N: T(n) \geq c\cdot f(n) \quad \forall n \geq n_0
\]
dove \(c\) e \(n_0\) sono indipendenti da \(n\).

\subsection{Complessità temporale di un algoritmo esaustivo}
Data un'istanza di un problema di ottimizzazione combinatoria, con cardinalità dell'insieme base \(n=\abs{B}\), \textbf{l'algoritmo esaustivo} ha complessità temporale almeno esponenziale:
\[
  T(n) \in \Omega(2^n)
\]
Solitamente, \(\a(n) e \beta(n)\) sono polinomi e la complessità risulta \textit{solo} esponenziali:
\[
  T(n) \in O(2^n\rnd{\a(n) + \beta(n)})
\]

\chapter{VCP}
\section{Bounded Tree Search}
Si tratta di una ricerca su albero, che termina dopo che ha esteso la ricerca di al più \(k\) livelli.
\begin{property}
  Per ogni lato \(\rnd{u,v} \in E\), qualsiasi soluzione ammissibile deve contenere almeno uno dei vertici:
  \[
    x \cap \rnd{u,v} \neq \emptyset
  \]
\end{property}
\begin{complexity}[Bounded Tree Search]
  La complessità temporale del Bounded Tree Search è:
  \[
    T(n,k) \in \Theta(2^k m)
  \]
  Risulta polinomiale in \(n\) e infatti per \(n>>2\) risulta \textbf{molto} più efficiente di quello ingenuo.
\end{complexity}

\section{Kernelization}
Consiste nel ridurre l'istanza a una molto più piccola con ugual soluzione.
\begin{property}
  Ogni vertice \(v\) di grado \(\delta_v \geq k+1\) deve appartenere a qualsiasi soluzione ammissibile di valore \(\leq k\).
\end{property}
\begin{complexity}
  La complessità dell'algoritmo Kernelization è:
  \[
    T(n,k) \in \Theta(n+m+2^{2k^2}k^2)
  \]
\end{complexity}
\end{document}
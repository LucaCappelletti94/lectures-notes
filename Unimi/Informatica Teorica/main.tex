\documentclass{lectures}
\DisableAdigraphs

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=2cm, minimum height=1cm,text centered, draw=black, fill=red!20]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!20]
\tikzstyle{decision} = [diamond, rounded corners, minimum width=2cm, minimum height=1cm, text centered, draw=black, fill=green!20]
\tikzstyle{arrow} = [thick,->,>=stealth]


\begin{document}

\maketitle{
  Informatica Teorica
}{
  Luca Cappelletti
}{
  Carlo Merenghetti
}{}{
  2019
}{6}{
  Informatica Magistrale
}{
  Università degli studi di Milano
}{
  Italia
}

\tableofcontents 
\part{Calcolabilità}
\chapter{Nozioni di base}
\section{Nozioni su funzioni}
\begin{multicols}{2}
\begin{definition}[Funzione]
    Dati due insiemi \(A\) e \(B\), una \textbf{funzione} \(f\) di dominio \(A\) e codominio \(B\) è una legge che ad ogni elemento \(a \in A\) associa un elemento \(b \in B\).
\end{definition}
\begin{definition}[Funzione iniettiva]
    Una funzione \(f\) si dice \textbf{iniettiva} se e solo se: \[
        \f{x_1} = \f{x_2} \Rightarrow x_1=x_2
    \]
    Una funzione \textbf{iniettiva} è una funzione che associa a elementi distinti del dominio elementi distinti del codominio.
\end{definition}
\begin{definition}[Immagine di funzione]
    Si dice \textbf{immagine} di \(f\) l'insieme:
    \[
        \text{Im}_f \equiv \crl{y\mid \exists x \in A\rnd{y=\f{x}}}
    \]
\end{definition}
\begin{definition}[Funzione suriettiva]
    Una funzione si dice \textbf{suriettiva} se e solo se la sua immagine coincide con il codominio:
    \[
        \forall b \in B\: \exists a \in A: \; \f{a} = b
    \]
\end{definition}
\begin{definition}[Funzione biettiva]
Una \textbf{corrispondenza biunivoca} o \textbf{funzione biettiva} è una funzione \(\fdef{A}{B}\) tale che: \[\forall y \in B \quad \exists! x \in A: y = \f{x}\]

Una funzione è \textbf{biettiva} se e solo se è sia \textit{iniettiva} che \textit{suriettiva}.
\end{definition}
\begin{definition}[Funzione inversa]
    Data una funzione biettiva \(\fdef{A}{B}\) si dice \textbf{inversa} di \(f\) la funzione \(f^{-1}: B\Rightarrow A\) definita da \(x = f^{-1}\rnd{x}\) se e solo se \(y = \f{x}\)
\end{definition}
\begin{definition}[Composizione di funzioni]
    Date due funzioni \(\fdef{A}{B},\; \funcdef{g}{B}{C}\) in cui il codominio della prima coincide con il codominio della seconda diciamo \textbf{composizione}:
    \[
        \funcdef{g \circ f}{A}{C}
    \]
    la funzione definita tramite la legge:
    \[
        \rnd{f\circ g}\rnd{x}  = \g{\f{x}}
    \]
\end{definition}
\begin{definition}[Funzione identità]
    La funzione \(\funcdef{I_A}{A}{A}\) definita da \(\forall a \rnd{I_A\rnd{a} = a}\) si chiama funzione \textbf{identità} su A.
    
    Se \(\fdef{A}{B}\) allora \(I_B \circ f = f\) o \(f \circ I_A = f\). Inoltre, se \(\fdef{A}{B}\) è una corrispondenza biunivoca, allora \(f \circ f^{-1} = I_B\) e \(f^{-1} \circ f = I_A\).
\end{definition}
\begin{definition}[Funzione definita e indefinita]
Se all'elemento \(a \in A\) viene associato un elemento di \(B\), diremo che \(f\) è \textbf{definita} su \(a\), altrimenti verrà detta \textbf{indefinita}.
\end{definition}
\begin{definition}[Indefinito]
    Il simbolo utilizzato per indicare \textbf{indefinito} è: \[\bot\]
\end{definition}
\begin{definition}[Dominio di definizione]
    Data una funzione \(\fdef{A}{B}\), si dice \textbf{Dominio} di definizione:
    \[
        A = \crl{x \mid x \in A, \f{x} \text{ definita}}
    \]
\end{definition}
\begin{definition}[Funzione parziale]
    Una funzione parziale \(\fdef{A}{B}\) può essere pensata come una funzione:
    \[
        \funcdef{\bar{f}}{A}{B \cup \crl{\bot}}
    \]
    dove \(\bot\) è un simbolo (distinto) di indefinito:
    \[
        \bar{f}\rnd{x} = \begin{cases}
            \f{x} & \text{se definita}\\
            \bot & \text{se indefinita}
        \end{cases}
    \]
\end{definition}
\end{multicols}
\clearpage
\section{Nozioni su insiemi}
\begin{multicols}{2}
\begin{definition}[Coprodotto di insiemi o Unione Disgiunta]
Dati due insiemi \(A\) e \(B\) diciamo \textbf{unione disgiunta} di \(A\) e \(B\) l'insieme \(A \sqcup B\) unione di due coppie isomorfe e disgiunte di \(A\) e \(B\), cioè:
\[
    A \sqcup B = \crl{\rnd{a,1} \mid a \in A} \cup \crl{\rnd{b,2}\mid b \in B}
\]
Le due iniezioni \(\funcdef{i}{A}{A \sqcup B}\) e \(\funcdef{j}{B}{A \sqcup B}\) sono definite da \(i\rnd{a} = \rnd{a,1}\) e \(j\rnd{b} = \rnd{b,1}\) rispettivamente.
\end{definition}
\begin{definition}[Prodotto Cartesiano]
    Dati \(n\) insiemi, non vuoti, \(A_1, \ldots, A_n\), il prodotto cartesiano:
    \[
        A_1 \times \ldots \times A_n = \crl{\ngle{a_1, \ldots, a_n}}
    \]
    è l'insieme delle \(n\)-uple ordinate in cui l'\(i\)-esimo elemento è preso dall'\(i\)-esimo insieme.
\end{definition}
\begin{definition}[Insieme delle funzioni]
    Siano \(A\) e \(B\) due insiemi non vuoti di elementi. Si definisce insieme delle funzioni da \(A\) a \(B\) l'insieme:
    \[
        A^B = \crl{\funcdef{f}{A}{B \cup \crl{\bot}}}
    \]
    delle funzioni (totali o parziali) che hanno \(A\) come dominio e \(B\) come codominio.
\end{definition}
\begin{definition}[Insiemi isomorfi]
    Dati due insiemi \(A\) e \(B\), essi sono \textbf{isomorfi}, scrivendo \(A \simeq B\), se esiste una corrispondenza biunivoca:
    \[
        \fdef{A}{B}
    \]
\end{definition}
\begin{definition}[Cardinalità]
    Chiameremo la classe quoziente classe della cardinalità. In particolare cardinalità del numerabile è la classe di equivalenza contenente:
    \[
        \N = \crl{0,1,2,\ldots, n, \ldots}
    \]
\end{definition}
\begin{theorem}[Teorema di Cantor]
    L'insieme \(\N^\N\) delle funzioni da \(\funcdef{f}{\N}{\N}\) non è numerabile:
    \[
        \N \not\simeq \N^{\N}
    \]
    In altre parole, \(\N\) non è \textbf{isomorfo} a \(\N^{\N}\): non è possibile enumerare gli elementi all'interno dell'insieme \(\N^\N\).
\end{theorem}
\begin{proof}[Teorema di Cantor]
    Per dimostrare che \(\N^\N\) non è numerabile dovremo provare che non è possibile elencare tutti gli elementi di \(\N^\N\).
    
    La dimostrazione si sviluppa per assurdo: se \(\N^\N\) fosse numerabile, dovremmo riuscire ad elencare tutti i suoi elementi costruendo una tabella in cui le righe corrispondono a tutte e sole le funzioni di \(\N^\N\) e le colonne corrispondono ai numeri naturali:
    \begin{table}
        \begin{tabular}{C|CCCCC}
             & 0 & 1 & 2 & \ldots & n\\
             \hline
             f_0 & f_0\rnd{0} & f_0\rnd{1} & f_0\rnd{2} & \ldots & f_0\rnd{n} \\
             f_1 & f_1\rnd{0} & f_1\rnd{1} & f_1\rnd{2} & \ldots & f_1\rnd{n} \\
             \vdots & \vdots & \vdots& \vdots& \vdots& \vdots\\
             f_n & f_n\rnd{0} & f_n\rnd{1} & f_n\rnd{2} & \ldots & f_n\rnd{n} \\
        \end{tabular}
    \end{table}
    La tabella così costruita associa ad ogni \(\funcdef{f}{\N}{\N}\) di \(\N^\N\) e ad ogni intero \(n \in \N\) il valore in \(n\) di \(f\). Si prenda allora la funzione \(\funcdef{g}{\N}{\N}\) definita come:
    \[
        g\rnd{n} = f_n\rnd{n} + 1
    \]
    È facile verificare che \(g\) non coincide con nessuna delle \(f_i\), elencate nella tabella. Infatti, se \(g\) fosse \(f_i\) per qualche intero \(i\), si avrebbe l'assurdo:
    \[
        f_i\rnd{i} = f_i\rnd{i} + 1
    \]
    Pertanto \(\N^\N\) non è numerabile.
\end{proof}
\begin{observation}[Osservazione sul teorema di Cantor, esistenza di funzioni non computabili]
    Siccome in un sistema digitale i programmi devono essere specificati con una quantità finita di informazione, ogni dato e quindi ogni programma può essere descritto da un intero:
    \[
        \text{Dati} \simeq \N, \quad \text{Programmi} \simeq \N
    \]
    L'insieme delle funzioni computabili da un dato sistema, descritto da:
    \[
        \funcdef{C}{\text{Dati} \times \text{Programmi}}{\text{Dati} \cup \crl{\bot}}
    \]
    è allora il set delle funzioni computabili \textit{FC} è equivalente a:
    \[
        FC \equiv \crl{f \mid \funcdef{f}{\N}{\N \cup \crl{\bot}}, \exists P \in \text{Programmi}\rnd{\f{x} = C\rnd{x, P}}}
    \]
    Allora:
    \[
        FC \simeq \text{Programmi} \simeq \N \not\simeq \rnd{\N \cup \crl{\bot}}^{\N}
    \]
    \textbf{Esistono quindi funzioni non computabili}, e il problema di caratterizzare la classe di quelle computabili è ben posto.
\end{observation}
\end{multicols}
\clearpage
\begin{multicols}{2}
\begin{theorem}[Funzioni coppia di Cantor]
    L'insieme dei dati \(\N \times \N\) è \textbf{isomorfo} all'insieme dei numeri naturali \(\N\) cioè coppie ordinate di interi possono essere poste in corrispondenza biunivoca con gli interi utilizzando la funzione coppia di Cantor:
    \[
        \funcdef{\ngle{\;,\;}}{\N \times \N}{\N^{+}}
    \]
\end{theorem}
\begin{proof}[Funzioni coppia di Cantor]
    È sufficiente considerare la seguente tabella:
    \begin{table}
        \begin{tabular}{c|CCCCCC}
             \diagbox{\(x\)}{\(y\)} & 0 & 1 & 2 & 3 & 4 & \ldots\\
             \hline
             0 & 1  & 3  & 6  & 10 & 15 & \ldots\\
             1 & 2  & 5  & 9  & 14 & \ldots & \ldots\\
             2 & 4  & 8  & 13 & \ldots & \ldots & \ldots\\
             3 & 7  & 12 & \ldots & \ldots & \ldots & \ldots\\
             4 & 11 & \ldots & \ldots & \ldots & \ldots & \ldots\\
             \vdots & \ldots & \ldots & \ldots & \ldots & \ldots & \ldots\\
        \end{tabular}
    \end{table}
    È chiaro come, estendendo tale legge, a ogni coppia \(\rnd{x,y}\) corrisponda un preciso intero positivo \(n = \ngle{x,y}\) e viceversa. Non è difficile ottenere esplicitamente la funzione \(\ngle{x,y}\) come composizione di operazioni aritmetiche, infatti:

    \textbf{Lungo l'asse \(x\) è:}
    \[
        \ngle{x,0} = 1 + 1+ 2 + \ldots + z = 1 + \frac{z \cdot \rnd{z+1}}{2}
    \]
    \textbf{Lungo la diagonale è:}
    \[
        \ngle{z-y, y} = \ngle{z, 0} + y = 1 + \frac{z\cdot\rnd{z+1}}{2} + y
    \]
    Posto \(x=z-y\) otteniamo:
    \[
        \ngle{x,y} = 1 + \frac{\rnd{x+y}\rnd{x+y+1}}{2} + y
    \]
\end{proof}
\end{multicols}
\clearpage
\begin{corollary}[Funzioni proiezione]
    Data la funzione coppia \(\funcdef{\ngle{\;,\;}}{\N\times\N}{\N^{+}}\) definita da:
    \[
        \ngle{x,y} = 1 + \frac{\rnd{x+y}\rnd{x+y+1}}{2} + y
    \]
    vogliamo costruire le due \textbf{funzioni proiezione}:
    \[
        \funcdef{\text{sin}}{\N^{+}}{\N} \text{ e } \funcdef{\text{des}}{\N^{+}}{\N}
    \]
    tali che per ogni intero \(n\geq 1\) valga \(\ngle{\text{sin}\rnd{n}, \text{des}\rnd{n}} = n\).
    
    Per come è costruita la funzione coppia, per ogni intero \(n \geq 1\) esiste un intero \(z \geq 0\) per cui valgono le seguenti uguaglianze:
    \[
        n = \ngle{z-\text{des}\rnd{n}, \text{des}\rnd{n}} = 1 + \frac{z\cdot\rnd{z+1}}{2} + \text{des}\rnd{n}
    \]
    Riprendendo la tabella dalla dimostrazione delle funzioni coppia, notiamo che \(z\) corrisponde all'ascissa del primo elemento della diagonale su cui si trova \(n\). In altre parole, \(z\) è l'unico intero tale che:
    \[
        \ngle{z,0} \leq n < \ngle{z+1, 0}
    \]
    da cui:
    \[
        1+\frac{z\cdot\rnd{z+1}}{2}\leq n < 1 + \frac{\rnd{z+1}\rnd{z+2}}{2}
    \]
    Risolvendo per \(z\) otteniamo:
    \[
        \sqrt{2n-\frac{7}{4}} - \frac{3}{2} < z \leq \sqrt{2n - \frac{7}{4}} - \frac{1}{2}
    \]
    e quindi:
    \[
        z = \floor{\sqrt{2n-\frac{7}{4}} - \frac{1}{2}}
    \]
    Dimostreremo ora che \(z\) può essere calcolato mediante la formula:
    \[
        z = \text{round}\rnd{\sqrt{2n}}-1 = \floor{\sqrt{2n-\frac{7}{4}} - \frac{1}{2}}
    \]
    Supponendo che la relazione sia falsa, si ottengono 3 casi possibili:
    \begin{enumerate}
        \item Esiste un intero \(k\) tale che:
        \[
            \floor{\sqrt{2n-\frac{7}{4}} + \frac{1}{2}} \geq k+1 \quad \land \quad \text{round}\rnd{\sqrt{2n}} \leq k
        \]
        Questo implica \(\sqrt{2n-\frac{7}{4}} \geq k + \frac{1}{2} \quad \land \quad \sqrt{2n} < k + \frac{1}{2}\), da cui l'assurdo: \(\sqrt{2n} < \sqrt{2n-\frac{7}{4}}\).
        \item Esiste un intero \(k\) tale che:
        \[
            \floor{\sqrt{2n-\frac{7}{4}} + \frac{1}{2}} \leq k \quad \land \quad \text{round}\rnd{\sqrt{2n}} \geq k+1
        \]
        Questo implica \(\sqrt{2n - \frac{7}{4}}<k + \frac{1}{2} \quad \land \quad \sqrt{2n} \geq k+\frac{1}{2}\). Elevando al quadrato otteniamo:
        \[
            2n < k^2 + k + 2 \quad \land \quad 2n \geq k^2 + k + \frac{1}{4} \quad \Rightarrow \quad \frac{k^2+k}{2} + \frac{1}{8} \leq n < \frac{k^2+k}{2} +1
        \]
        Siccome \(\frac{k^2+k}{2}\) è un intero, è immediato concludere che nessun intero \(n\) può soddisfare la relazione e pertanto anche in questo caso abbiamo ottenuto un assurdo.
    \end{enumerate}
    Le identità sono pertanto dimostrate e sostituendo \(z\) otteniamo le formule per il calcolo delle proiezioni:
    \[
        \text{sin}\rnd{n} = \text{round}\rnd{\sqrt{2n}}\frac{\text{round}\rnd{\sqrt{2n}}+1}{2}-n \quad \quad \text{des}\rnd{n} = n -  \text{round}\rnd{\sqrt{2n}}\frac{\text{round}\rnd{\sqrt{2n}}+1}{2}
    \]
\end{corollary}
\chapter{Linguaggi di programmazione}
\begin{multicols}{2}
\begin{definition}[Linguaggio di programmazione (aspetto sintattico)]
Un \textit{linguaggio di programmazione} da un punto di vista \textbf{sintattico} è un insieme (generalmente infinito) di programmi, dove con "programma" si indica una particolare sequenza finita di simboli di un dato alfabeto.
\end{definition}
\begin{definition}[Linguaggio di programmazione (aspetto semantico)]
Un \textit{linguaggio di programmazione} da un punto di vista \textbf{semantico} è un insieme (generalmente infinito) di programmi, dove con "programma" si indica un insieme di regole che trasformano il dato di ingresso nell'eventuale dato di uscita: il significato di un programma è la funzione parziale realizzata.
\end{definition}
\begin{definition}[Significato di RAM]
    Con RAM si intende \textbf{Random Access Machines}, cioè macchine ad accesso casuale, si tratta di macchine a registri.
\end{definition}
\begin{definition}[Linguaggio RAM]
    Si tratta di un meccanismo di calcolo che presenta alcune affinità con quelli reali, ed è usato appunto per le macchine RAM.
\end{definition}
\begin{definition}[Sintassi del linguaggio RAM ridotto]
    Un programma RAM (ridotto) è una sequenza finita di istruzioni appartenenti a uno dei seguenti tre tipi:
    \begin{enumerate}
        \item \(R_k \leftarrow R_k + 1\)
        \item \(R_k \leftarrow R_k - 1\)
        \item \(\text{If }R_k=0\text{ then goto }n\)
    \end{enumerate}
    dove \(k\) ed \(n\) sono interi non negativi.
\end{definition}
\begin{definition}[Grammatica delle istruzioni nel linguaggio RAM ridotto]
    Le istruzioni del linguaggio RAM ridotto hanno il formato seguente:
    \[\ngle{\text{istruzione}} \rightarrow \begin{cases}
        R_k \leftarrow R_k + 1\\
        R_k \leftarrow R_k - 1\\
        \text{If }R_k=0\text{ then goto }n
    \end{cases}
    \]
\end{definition}
\begin{definition}[Grammatica dei programmi nel linguaggio RAM ridotto]
    I programmi nel linguaggio RAM ridotto hanno il formato seguente:
    \[\ngle{\text{programma}} \rightarrow \begin{cases}
        \ngle{\text{istruzione}}\\
        \ngle{\text{istruzione}};\ngle{\text{programma}}
    \end{cases}
    \]
    Le istruzioni possono essere scritte in sequenza, separandole con il simbolo "\(;\)" o alternativamente a capo.
    
    Indichiamo con \textbf{Programmi} l'insieme dei programmi per RAM:
    \begin{align*}
        \mathbb{P} &= \text{Funzioni}\rnd{\text{RAM}}\\
        &= \crl{f\mid \funcdef{f}{\text{Dati}}{\text{Dati}\cup\crl{\bot}}, \exists P \in \text{Programmi: }f = \varphi_P}
    \end{align*}
\end{definition}
\begin{observation}[Registri di una macchina RAM]
    Una macchina RAM possiede \textbf{infiniti} registri: \(
        L, R_0, R_1, \ldots, R_j, \ldots
    \) ognuno capace di contenere un intero, con \(L\) utilizzato come \textbf{contatore delle istruzioni} o \textbf{program counter}.
\end{observation}
\begin{observation}[Tipo dei dati di una macchina RAM]
    Una macchina RAM utilizza dati di tipo \textbf{intero}.
\end{observation}
\begin{observation}[Inizializzazione di una macchina RAM]
    La macchina RAM viene inizializzata ponendo \(1\) in \(L\) e il dato di ingresso \(x\) in \(R_1\). Tutti gli altri registri sono azzerati.
\end{observation}
\begin{observation}[Esecuzione di una macchina RAM]
    L'esecuzione viene effettuata dalla \textbf{Unità Centrale}, che accede all'informazione contenuta nei registri con \textit{accesso casuale}. Le istruzioni vengono eseguite in sequenza, incrementato \(L\) di \(1\) a meno che l'istruzione di salto condizionato non alteri la sequenzialità.
\end{observation}
\begin{observation}[Terminazione di una macchina RAM]
    Il programma di una macchina RAM termina quando il contenuto di \(L\) è 0.
\end{observation}
\begin{observation}[Posizione del dato di uscita di una macchina RAM]
    Il dato di uscita di un programma di una macchina RAM \(y\) è il contenuto di \(R_0\).
\end{observation}
\end{multicols}
\clearpage
\section{Semantica di una macchina RAM}
\begin{multicols}{2}
    \begin{definition}[Stato di una macchina RAM]
        Con \textbf{stato} si intende una funzione \(\funcdef{S}{\crl{L,R_0, R_1,R_2,\ldots}}{N}\), l'intero \(S\rnd{R_j}\) è detto contenuto di \(R_j\) nello stato \(S\). Intuitivamente, lo stato è una \textit{fotografia} dei contenuti dei registri in un certo istante. Indichiamo con \textbf{Stati} l'insieme degli stati.
    \end{definition}
    \begin{definition}[Stato finale di una macchina RAM]
        Lo \textbf{stato finale} è uno stato \(S\) in cui \(S\rnd{L} = 0\).
    \end{definition}
    \begin{definition}[Dato]
        Con \textbf{Dato} si intende un qualsiasi intero non negativo. Indichiamo con \textit{Dati} l'insieme dei dati \(\crl{0,1,2,\ldots,n\ldots}\).
    \end{definition}
    \begin{definition}[Inizializzazione di una macchina RAM]
        Con \textbf{inizializzazione} è la funzione in: \(\text{Dati}\rightarrow\text{Stati}\) definita come segue:
        \(
            x \mapsto S_{in}
        \) dove:
        \[
            S_{in}\rnd{L} = 1, \quad S_{in}\rnd{S_j} = \begin{cases}
                x & \text{se }j=1\\
                0 & \text{altrimenti}
            \end{cases}
        \]
    \end{definition}
    \begin{definition}[Numero di istruzioni di un programma]
        Dato un programma \(P\) indichiamo il numero di istruzioni del programma con \(\abs{P}\).
    \end{definition}
    \begin{definition}[Sequenza di computazione]
        Con \textbf{sequenza di computazione} del programma \(P\) sul dato \(x\) è una successione \(\crl{S_0, S_1, \ldots, S_n}\) di stati tali che:
        \begin{enumerate}
            \item \(S_0 = \text{in}\rnd{x}\)
            \item \(S_{e+1} = \delta\rnd{S_e, P} \quad \rnd{0 \leq e < n}\)
        \end{enumerate}
    \end{definition}
    \begin{observation}[A cosa serve la sintassi?]
    La sintassi ci ha permesso di definire il linguaggio di programmazione \textbf{Programmi}.
\end{observation}
\begin{observation}[A cosa serve la semantica?]
    La semantica ci permette di definire il sistema di programmazione \(\crl{\varphi_P}\). Essa può essere vista come una funzione del tipo:
    \[
        \funcdef{\text{Semantica}}{\text{Programmi}}{\rnd{\text{Dati} \cup \crl{\bot}}^{\text{Dati}}}
    \]
    L'immagine della funzione è l'insieme delle funzioni che ammetto programmi in grado di computarle.
\end{observation}
    \begin{definition}[Sequenza di computazione accettata]
        Con \textbf{sequenza di computazione accettata} dal programma \(P\) sul dato \(x\) è una sequenza di computazione \(\ngle{S_0, \ldots, S_n}\) dove \(S_n\) è uno stato finale \(\rnd{S_n\rnd{L}} = 0\).
    \end{definition}
    \begin{definition}[Stato prossimo]
        Con lo \textbf{stato prossimo} è la funzione (parziale) (detta anche \textit{funzione di transizione di stato}):
        \[
            \funcdef{\delta}{\text{Stati} \times \text{Programmi}}{Stati}
        \]
        dove \(S' = \delta\rnd{S,P}\) è definito dalla seguente procedura:
        \begin{description}
            \item[Caso \(S\rnd{L}=0\)] allora \(S'\) è indefinito, cioè \(S' = \bot\).
            \item[Caso \(S\rnd{L}>\abs{P}\)] allora \(S'\rnd{L}=0\), \(S'\rnd{R_j} = S\rnd{R_j}\rnd{\text{con }i\geq 0}\) gli altri registri vengono non modificati.
            \item[Caso \(0 < S\rnd{L} \leq \abs{P}\)] allora seleziona l'istruzione \(S\rnd{L}\) in \(P\) diciamo \textit{istr}:
                \begin{description}
                    \item[ADD] se \textit{istr} è del tipo \(R_k \leftarrow R_k + 1\):
                    \begin{align*}
                        S'\rnd{L} &= S\rnd{L} +1\\
                        S'\rnd{R_j} &= \begin{cases}
                            S\rnd{R_j}+1 & \text{se }j=k\\
                            S\rnd{R_j} & \text{altrimenti}
                        \end{cases}
                    \end{align*}
                    \item[SUB] se \textit{istr} è del tipo \(R_k \leftarrow R_k - 1\):
                    \begin{align*}
                        S'\rnd{L} &= S\rnd{L} +1\\
                        S'\rnd{R_j} &= \begin{cases}
                            S\rnd{R_j}-1 & \text{se }j=k\\
                            S\rnd{R_j} & \text{altrimenti}
                        \end{cases}
                    \end{align*}
                    \item[IF] se \textit{istr} è del tipo \(\text{If }R_k=0\text{ then goto }m\):
                    \begin{align*}
                        S'\rnd{L} &= \begin{cases}
                            m & \text{se }S\rnd{R_k}=0\\
                            S\rnd{L}+1 & \text{altrimenti}
                        \end{cases}\\
                        S'\rnd{R_j} &= S\rnd{R_j}\\
                    \end{align*}
                \end{description}
        \end{description}
    \end{definition}
    \begin{definition}[Funzione computata]
        Con \textbf{funzione computata} del programma \(P\) è la funzione:
        \[
            \funcdef{\varphi_P}{\text{Dati}}{\text{Dati}\cup\crl{\bot}}
        \]
        è la composizione delle funzioni (inizializzazione, transizione di stati iterata, estrazione del risultato) definita da:
        \[
            \varphi_P\rnd{x} = \begin{cases}
                y & \parbox{0.7\textwidth}{Se esiste una sequenza di computazione \(\ngle{S_0, \ldots, S_n}\) accettata da \(P\) sul dato \(x\) ed inoltre \(y = S_n\rnd{R_0}\)}\\
                \bot & \text{altrimenti}
            \end{cases}
        \]
        La funzione \(\varphi_P\) è \textbf{parziale}, essendo possibili sequenze di computazioni infinite. Vedremo che tale fenomeno è inevitabile.
    \end{definition}
\end{multicols}
\clearpage
\section{Linguaggio While}
\subsection{Sintassi del linguaggio While}
\begin{multicols}{2}
    \begin{definition}[Comando di assegnamento in sintassi While]
        Un \textbf{comando di assegnamento} nel linguaggio While è del tipo:
        \[
            x_k = 0,\quad x_k=x_j+1,\quad x_k=x_j-1 \qquad \rnd{0 \leq k, j \leq 20}
        \]
        dove \(x_k\) e \(x_j\) sono dette variabili. Si va a limitare il numero dei registri.
    \end{definition}
    \begin{definition}[Comando While]
        Un \textbf{comando while} è un commento del tipo:
        \[
            \text{while }x_k\neq 0 \text{ do }C\qquad \rnd{0\leq k\leq 20}
        \]
        con \(C\) un comando arbitrario.
    \end{definition}
    \begin{definition}[Comando composto in sintassi While]
        Un \textbf{comando composto} nel linguaggio While è del tipo:
        \[
            \text{begin }C_1;C_2;\ldots;C_m\text{ end} \qquad \rnd{0<m}
        \]
        essendo \(C_1,\ldots,C_m\) comandi arbitrari.
    \end{definition}
    \begin{definition}[Programma While]
        Un \textbf{programma while} è un comando composto. Indichiamo con \textbf{W-Programmi} l'insieme dei programmi while:
        \begin{align*}
            \mathbb{W} &= \text{Funzioni}\rnd{\text{while}}\\ &= \crl{g\mid \funcdef{g}{\text{Dati}}{\text{Dati}\cup \crl{\bot}}, \exists P \in \text{W-Programmi }\rnd{g = \psi_P}}
        \end{align*}
    \end{definition}
\end{multicols}
\subsection{Grammatica del linguaggio While}
\begin{multicols}{2}
\begin{definition}[Grammatica di programma in linguaggio While]
    La grammatica di un \textbf{programma} in linguaggio While è:
    \[
        \ngle{\text{programma}} \rightarrow \ngle{\text{comando composto}}
    \]
\end{definition}
\begin{definition}[Grammatica di comando in linguaggio While]
    La grammatica di un \textbf{comando} in linguaggio While è:
    \[
        \ngle{\text{com.}} \rightarrow \ngle{\text{assegnamento}} / \ngle{\text{com. while}} / \ngle{\text{com. composto}}
    \]
\end{definition}
\begin{definition}[Grammatica di assegnamento in linguaggio While]
    La grammatica di un \textbf{assegnamento} in linguaggio While è:
    \[
        \ngle{\text{assegn.}} \rightarrow x_k = 0 / x_k = x_j+1 / x_k = x_j -1 \quad \rnd{0\leq k, j\leq 20}
    \]
\end{definition}
\begin{definition}[Grammatica di comando while in linguaggio While]
    La grammatica di un \textbf{comando while} in linguaggio While è:
    \[
        \ngle{\text{com. while}} \rightarrow \text{while } x_k \neq 0 \text{ do }\ngle{\text{com.}}\quad\rnd{0\leq k \leq 20}
    \]
\end{definition}
\begin{definition}[Grammatica di sequenza di comandi in linguaggio While]
    La grammatica di una \textbf{sequenza di comandi} in linguaggio While è:
    \[
        \ngle{\text{sequenza di com.}} \rightarrow \ngle{\text{com.}} / \ngle{\text{com.}}\ngle{\text{sequenza di com.}}
    \]
\end{definition}
\begin{definition}[Grammatica di comando composto in linguaggio While]
    La grammatica di una \textbf{sequenza di comandi} in linguaggio While è:
    \[
        \ngle{\text{com. composto}} \rightarrow  \text{begin }\ngle{\text{sequenza di com.}}\text{ end}
    \]
\end{definition}
\begin{observation}[Come dimostrare che una proprietà \(P\) valga per tutti i programmi]
    Per poter dimostrare che una proprietà \(P\) vale per tutti i programmi basterà dimostrare due proprietà:
    \begin{enumerate}
        \item La proprietà \(P\) vale per tutti i comandi di assegnamento.
        \item Se la proprietà \(P\) vale per \(C\), allora vale per:
        \[
            C' \equiv \text{while }x_k \neq 0\text{ do }C
        \]
        Se \(P\) vale per \(C_1, \ldots, C_m\), allora vale per:
        \[
            C' \equiv \text{begin }C_1;\ldots;C_m\text{ end}
        \]
    \end{enumerate}
\end{observation}
\end{multicols}
\clearpage
\subsection{Semantica operazionale}
\begin{multicols}{2}
    \begin{definition}[Stato nel linguaggio While]
        Nel linguaggio while, uno \textbf{stato} è una funzione:
        \[
            \funcdef{\bmx}{\crl{x_0,x_1,\ldots,x_{20}}}{\N}
        \]
        Indichiamo con \(w-\text{Stati}\) l'insieme degli stati \(N^{21}\).
    \end{definition}
    \begin{observation}[Differenze tra registri nel linguaggio RAM e While]
        A differenza dell'analoga nozione per il linguaggio RAM, non abbiamo necessità di introdurre il registro \(L\), in quanto il nostro linguaggio while non ha istruzioni di salto. La limitazione a soli \(21\) registri di memoria è per semplicità e, come vedremo, non limita la capacità computazionale.
    \end{observation}
    \begin{definition}[Dato nel linguaggio While]
        Nel linguaggio while, un \textbf{dato} è un qualsiasi intero non negativo.
    \end{definition}
    \begin{definition}[Inizializzazione nel linguaggio while]
        Con \textbf{inizializzazione} è la funzione:
        \[
            \funcdef{w-\text{in}}{\text{\text{Dati}}}{w-\text{Stati}}
        \]
        dove:
        \[
            w-\text{in}\rnd{x} = \rnd{0,x_1,0,0,\ldots,0}
        \]
    \end{definition}
    \begin{definition}[Semantica nel linguaggio While]
        Nel linguaggio while la \textbf{semantica} del programma \(P\) è la funzione:
        \[
            \funcdef{\psi_P}{\text{Dati}}{\text{Dati}\cup\crl{\bot}}
        \]
        dove: \(\psi_P\rnd{x} = \text{Componente di indice \(0\) in \(\ssqr{P}\rnd{w-\text{in}\rnd{x}}\)}\).
        
        Diremo anche che \(\psi_P\) è la funzione calcolata dal programma \(P\), e \(\crl{\psi_P}\) il sistema di programmazione del linguaggio while.
    \end{definition}
    \begin{definition}[Semantica nel linguaggio while]
        La \textbf{semantica} dei comandi è una funzione parziale, detta funzione di transizione di stato:
        \[
            \funcdef{\ssqr{\quad}()}{\text{Comandi}\times w-\text{Stati}}{w-\text{Stati}}
        \]
        Sia \(C\) un comando, \(\bmx\) uno stato: definiamo \(\bmy =\ssqr{C}\rnd{\bmx}\) (intuitivamente, il risultato del comando \(C\) sullo stato \(\bmx\)) per ricorrenza.
        \begin{description}
            \item[Caso \(C\equiv x_k =0\):] \(y_j = \begin{cases}
                0 & \text{Se }k=j\\
                x_j & \text{Altrimenti}
            \end{cases}\)
            \item[Caso \(C\equiv x_k =x_i+1\):] \(y_j = \begin{cases}
                x_i+1 & \text{Se }k=j\\
                x_j & \text{Altrimenti}
            \end{cases}\)
            \item[Caso \(C\equiv x_k =x_i-1\):] \(y_j = \begin{cases}
                x_i-1 & \text{Se }k=j\\
                x_j & \text{Altrimenti}
            \end{cases}\)
            \item[Caso \(C\equiv \text{begin }C_1;\ldots;C_m\text{ end}\):] \(\ssqr{C}\rnd{\bmx} = \ssqr{C_m} \circ \ssqr{C_{m-1}} \circ \ldots \circ \ssqr{C_1}\rnd{\bmx}\), dove \(\circ\) è la composizione fra funzione. Si va a invertire l'indice perché avviene la composizione di funzioni.
            \item[Caso \(C \equiv \text{while }x_k \neq 0 \text{ do} C_1\):]\[
                \ssqr{C}\rnd{\bmx} = \begin{cases}
                    {\ssqr{C_1}}^{\mu_e \text{(componente \(k\)-esima in \({\ssqr{C_1}}^e\rnd{\bmx}=0\))}}\rnd{\bmx}\\
                    \circ \bot
                \end{cases}
            \]
            Questo comando introduce l'indefinito perché \(x_k = 0\) può non essere verificata. In particolare la notazione significa:
            \[
                \ssqr{C_1}^e = \ssqr{C_1} \circ \ssqr{C_1} \circ \ldots \circ \ssqr{C_1} \quad \rnd{e \text{ volte}}
            \]
            Con \(\mu_e\) intendiamo il primo intero non negativo tale che la \(k\)-esima componente della funzione \(\ssqr{C_1}^e\) valutata sull'argomento \(\bmx\) risulta \(0\).
            Se questo non succede mai, conveniamo di porre \(\ssqr{C}\rnd{\bmx} = \bot\) (indefinito) convenendo inoltre che \(\ssqr{C} \circ \bot = \bot \circ \ssqr{C} = \bot\).
            
            Siamo ora in grado di associare ad ogni comando \(C\) una funzione parziale \(\funcdef{\ssqr{C}}{w-\text{Stati}}{w-\text{Stati}}\): essa esegue tutte le istruzioni in un blocco unico. Non c'è una sequenza di stati data dalla funzione \(\delta\).
            
            Poiché un programma \(P\) è in particolare un comando (comando composto), associamo a \(P\) la funzione parziale:
            \[
                \funcdef{\ssqr{P}}{w-\text{Stati}}{w-\text{Stati}}
            \]
        \end{description}
    \end{definition}
\end{multicols}
\clearpage
\section{Compilatore: da W-Programmi a Programmi RAM}
\begin{multicols}{2}
\begin{definition}[Traduzione]
    Siano \(L_1\) e \(L_2\) due linguaggi di programmazione, con rispettivi sistemi di programmazione \(\crl{\psi_{P_1}}\) e \(\crl{\varphi_{P_2}}\).
    
    Una \textbf{traduzione} è una funzione \(\funcdef{T}{L_1}{L_2}\) tale che:
    \begin{enumerate}
        \item \(T\) è una funzione totale calcolabile in PASCAL: questa condizione dice che \(T\) deve essere effettivamente calcolabile.
        \item \(T\) mantiene la semantica inalterata, cioè \(\forall P \in L_1: \;\; \psi_P = \varphi_{T\rnd{P}}\)
    \end{enumerate}
\end{definition}
\begin{definition}[Traduzione guidata della sintassi]
    Se il linguaggio è definito induttivamente dalla sintassi, è spesso possibile descrivere la traduzione \(T\) in termini ricorsivi sulla costruzione del linguaggio: si parla in tal caso di \textbf{traduzione guidata della sintassi}.
\end{definition}
\begin{observation}[A cose serve una traduzione?]
    Chiamato \(\textit{Funzioni}\rnd{L_i}\) l'insieme delle funzioni computabili in \(L_i\), è chiaro che se esiste una traduzione \(\funcdef{T}{L_1}{L_2}\) allora:
    \[
        \text{Funzioni}\rnd{L_1} \subseteq \text{Funzioni}\rnd{L_2}
    \]
    la costruzione di una traduzione (programma compilatore) è allora uno strumento per il nostro problema di confronto tra classi di funzioni.
\end{observation}
\end{multicols}
\begin{theorem}[Correttezza del compilatore]
    Procediamo a costruire una traduzione \(\funcdef{\text{Conf}}{W-\text{Programmi}}{\text{Programmi}}\). Sia \(C\) un comando qualsiasi, allora:
    \begin{description}
        \item[Caso \(C\equiv x_k = 0\):]\(
            \text{Comp}\rnd{C} = \begin{cases}
                \text{LOOP}: \begin{cases}
                    R_k \leftarrow R_k -1\\
                    \text{IF }R_k = 0\text{ THEN GOTO EXIT}\\
                    \text{IF }R_{21} = 0\text{ THEN GOTO LOOP} \quad  \parbox{0.3\textwidth}{Il registro \(R_{21}\) è sempre a zero, pertanto la condizione risulta sempre vera.}
                \end{cases}\vspace{1em}\\
                \text{EXIT}: \begin{array}{r}
                    R_k \leftarrow R_k -1 \quad  \parbox{0.5\textwidth}{Si tratta di un'istruzione qualsiasi che non ha nessuna funzione.}
                \end{array}
            \end{cases}
        \)
        \item[Caso \(C\equiv x_k = x_j \pm 1\) con \(\rnd{k\neq j}\):]\(
            \text{Comp}\rnd{C} = \begin{cases}
                \underbrace{\text{LOOP}}_{\text{Azzera }R_k}: \begin{cases}
                    R_k \leftarrow R_k -1\\
                    \text{IF }R_k = 0\text{ THEN GOTO EXIT }1\\
                    \text{IF }R_{21} = 0\text{ THEN GOTO LOOP}
                \end{cases}\vspace{1em}\\
                \underbrace{\text{EXIT } 1}_{\text{Copio }R_j \text{ in }R_{22}}: \begin{cases}
                    \text{IF }R_j = 0\text{ THEN GOTO EXIT }2\\
                    R_j \leftarrow R_j -1\\
                    R_{22} \leftarrow R_{22} + 1\\
                    \text{IF }R_{21} = 0\text{ THEN GOTO EXIT }1\\
                \end{cases}\vspace{1em}\\
                \underbrace{\text{EXIT } 2}_{\parbox{0.2\textwidth}{Copio \(R_{22}\) che vale \(R_j\) in \(R_k\) e ancora in \(R_j\)}}: \begin{cases}
                    \text{IF }R_{22} = 0\text{ THEN GOTO EXIT }3\\
                    R_{22} \leftarrow R_{22} -1\\
                    R_{j} \leftarrow R_{j} + 1\\
                    R_{k} \leftarrow R_{k} + 1\\
                    \text{IF }R_{21} = 0\text{ THEN GOTO EXIT }2\\
                \end{cases}\vspace{1em}\\
                \text{EXIT } 3: \begin{array}{l}
                    R_k \leftarrow R_k \pm 1 \quad \text{alla fine in \(R_k\) devo avere \(R_j \pm 1\)}
                \end{array}
            \end{cases}
        \)
        \item[Caso \(C\equiv \text{begin }C_1;\ldots;C_m\text{ end}\):]\(\text{Comp}\rnd{C} = \begin{cases}
            \text{Comp}\rnd{C_1}\\
            \vdots\\
            \text{Comp}\rnd{C_m}
        \end{cases}\)
        \item[Caso \(C\equiv \text{while }x_k\neq 0 \text{ do }C_1\):]\(\text{Comp}\rnd{C} = \begin{cases}
            \text{LOOP}:\begin{cases}{r}
                \text{IF }R_{k} = 0\text{ THEN GOTO EXIT}\\
                \text{Comp}\rnd{C_1}\\
                \text{IF }R_{21} = 0\text{ THEN GOTO LOOP}\\
            \end{cases}\\
            \text{EXIT}:\begin{array}{r}
                R_{22}\leftarrow R_{22} - 1
            \end{array} \quad \parbox{0.4\textwidth}{l'istruzione serve come "riempitivo" ma non ha nessuna funzione.}
        \end{cases}
        \)
    \end{description}
    \textbf{Comp} è una funzione che ad programma in linguaggio while associa un programma in linguaggio RAM. \textit{Comp è una traduzione}.
\end{theorem}
\begin{proof}[Correttezza del compilatore]
    Verifichiamo che \textbf{Comp} rispetta le proprietà di una \textit{traduzione}:
    \begin{enumerate}
        \item Poiché è definita per ricorsione sulla definizione induttiva di \textbf{W-Programmi}, \textit{Comp} è una funzione totale, essa è inoltre facilmente programmabile in PASCAL.
        \item \begin{multicols}{2}
            Dobbiamo ora mostrare che \textbf{Comp} mantiene la semantica, cioè \(\forall P \in \text{W-Programmi}\quad\rnd{\psi_P = \varphi_{\text{Comp}\rnd{P}}}\).
            
            Cominciamo con l'osservare che se \(\bar{C} = \text{Comp}\rnd{C}\), allora \(\bar{C}\) contiene al più le variabili \(R_0, R_1, R_2, \ldots, R_{20}, R_{21}, R_{22}\) (\(C\) sia un qualsiasi comando).
            
            Con una immediata induzione, si osserva che se i registri \(R_{21}\) e \(R_{22}\) sono azzerati prima della esecuzione di \(\bar{C}=\text{Comp}\rnd{C}\), al termine dell'esecuzione il contenuto di \(R_{21}\) e \(R_{22}\) sarà nuovamente 0.
            
            Associamo ora ad ogni programma \(\bar{C} = \text{Comp}\rnd{C}\) una funzione \(
                \funcdef{\delta_{\bar{C}}}{\N^{21}}{\N^{21}\cup\crl{\bot}}
            \) che al vettore \(\rnd{x_0, x_1, \ldots, x_{20}}\) associa il vettore \(\rnd{y_0, y_1, \ldots, y_{20}}\) con la seguente regola: se \(x_k\;\rnd{0\leq k \leq 20}\) è il contenuto del registro \(R_k\) prima della esecuzione di \(C\) e i registri \(R_{21}\) e \(R_{22}\) sono azzerati, allora \(y_k\;\rnd{0\leq k \leq 20}\) è il contenuto di \(R_k\) dopo la esecuzione di \(\bar{C}\) (nel caso in cui la computazione termini).
            
            Poiché \(\text{w-Stati}=\N^{21}\), vale che:
            \[
                \funcdef{\delta_{\bar{C}}}{\text{w-Stati}}{\text{w-Stati}\cup\crl{\bot}}
            \]
            Dimostriamo ora, utilizzando lo schema di induzione prodotto dalla definizione induttiva dell'insieme dei comandi, che vale:
            \[
                \ssqr{C} = \delta_{\text{Comp}\rnd{C}}
            \]
        \end{multicols}
        \begin{enumerate}
            \item Sia \(A\) un comando di assegnamento. La verifica che: \(\ssqr{A} = \delta_{\text{Comp}\rnd{A}}\) è immediata.
            \item Sia \(C \equiv \text{begin }C_1;\ldots;C_m\text{ end}:\) valgono:
            \vspace{-1em}
            \begin{figure}
                \begin{subfigure}{0.49\textwidth}
                    \begin{align*}
                        \ssqr{C} &\equiv \ssqr{C_m} \circ \ssqr{C_{m-1}} \circ \ldots \circ \ssqr{C_1}\\
                        &= \delta_{C_m} \circ \delta_{C_{m-1}} \circ \ldots \circ \delta_{C_1}\\
                        &= \underbrace{\delta_{\text{Comp}\rnd{C_m}} \circ \ldots \circ \delta_{\text{Comp}\rnd{C_1}}}_{\text{Ipotesi d'induzione}}                
                    \end{align*}
                \end{subfigure}
                \begin{subfigure}{0.49\textwidth}
                    \begin{align*}
                        \delta_{\text{Comp}\rnd{C}} &= \delta_{\begin{cases}
                            \text{Comp}\rnd{C_1}\\
                            \vdots\\
                            \text{Comp}\rnd{C_m}
                        \end{cases}}\\ &= \delta_{\text{Comp}\rnd{C_m}} \circ \ldots \circ \delta_{\text{Comp}\rnd{C_1}}
                    \end{align*}
                \end{subfigure}
            \end{figure}
            e notando che i registri \(R_{21}\) e \(R_{22}\) sono uguali a zero: \(\ssqr{C} = \delta_{\text{Comp}\rnd{C}}\)
            \item \begin{multicols}{2}
                Sia \(C \equiv \text{while }x_k\neq 0\text{ do }C_1\), \(\delta_{\text{Comp}\rnd{C}}\rnd{\bmx}\) è ottenuto dal flow-chart interpretato:
                \vspace{1em}
                \begin{figure}
                    \begin{tikzpicture}[node distance=2cm]
                        \node (start) [startstop] {\(R \leftarrow x\)};
                        \node (check) [decision, below of=start] {\(R_x = 0\)};
                        \node (proc) [process, node distance=4cm, right of=check] {\(R \leftarrow \delta_{\text{Comp}\rnd{C_1}}\rnd{R}\)};
                        \node (stop) [startstop, below of=check] {Stop};
                        \draw [arrow] (start) -- (check) coordinate[midway] (aux){};
                        \draw [arrow] (check) -- node[anchor=east] {si} (stop);
                        \draw [arrow] (check) -- node[anchor=south] {no} (proc);
                        \draw [arrow] (proc) |- (aux);
                    \end{tikzpicture}
                \end{figure}
                Quindi \(\delta_{\text{Comp}\rnd{C}}\rnd{\bmx} = \delta^e_{\text{Comp}\rnd{C_1}}\rnd{\bmx}\) dove \(e\) è il primo intero per cui la \(k\)-esima componente di \(\delta^e_{\text{Comp}\rnd{\bmx}}\rnd{\bmx} = 0\).
                
                Poiché, per l'ipotesi di induzione, \(\delta_{\text{Comp}\rnd{C_1}}=\ssqr{C_1}\), vale allora:
                \[
                    \delta_{\text{Comp}\rnd{C}}\rnd{\bmx}=\ssqr{C_1}^e\rnd{\bmx}
                \]
                dove \(e\) è il primo intero per cui la \(k\)-esima componente è \(0\). Poiché inoltre, per definizione della semantica del comando while, è \(\ssqr{C}\rnd{\bmx} = \ssqr{C_1}^e\rnd{\bmx}\) concludiamo che per ogni comando \(C\) vale:
                \[
                    \ssqr{C} = \delta_{\text{Comp}\rnd{C}}
                \]
                Sia \(P\) un programma while: esso è un particolare comando, quindi \(\ssqr{P} = \delta_{\text{Comp}\rnd{P}}\). Allora concludiamo che:
                \begin{align*}
                    \psi_P\rnd{x} &= O-\text{esima componente di }\ssqr{P}\rnd{w-\text{in }x}\\
                    &= O-\text{esima componente di }\delta_{\text{Comp}\rnd{P}}\rnd{\text{in }x}\\
                    &=\varphi_{\text{Comp}\rnd{P}}\rnd{x}
                \end{align*}
            \end{multicols}
        \end{enumerate}
    \end{enumerate}
\end{proof}
\begin{theorem}[Conseguenza di correttezza del compilatore]
    Una immediata conseguenza del teorema di \textbf{correttezza del compilatore} è che ogni funzione computabile in linguaggio while è anche computabile in linguaggio RAM (ridotto), e pertanto vale quindi che:
    \[
        \text{Funzioni}\rnd{\text{While}} \subseteq \text{Funzioni}\rnd{\text{RAM}}
    \]
\end{theorem}
\section{Macroistruzioni}
\begin{theorem}[Esistenza di macroistruzioni]
    Esistono \textbf{macroistruzioni}, comandi che fanno riferimento a set di comandi noti, del tipo:
    \[
        x_i = \text{Operazione}\rnd{x_j, x_s} \qquad \text{oppure} \qquad x_i = \text{Operazione}\rnd{x_j} \qquad \rnd{i,j,s \leq 10}
    \]
    per il seguente elenco di operazioni:
    \begin{multicols}{2}
        \begin{description}
            \item[Somma:]\(\rnd{x+y}\)
            \item[Prodotto:]\(\rnd{x\cdot y}\)
            \item[Sottrazione fra interi positivi:]\(\rnd{x-y}\)
            \item[Divisione intera:]\(\rnd{x \div y}\)
            \item[Modulo:]\(\rnd{\ngle{x}_y}\)
            \item[Coppia di Cantor:]\(\rnd{\ngle{x,y}}\)
            \item[Proiezione destra di Cantor:]\(\rnd{\text{des }x}\)
            \item[Proiezione sinistra di Cantor:]\(\rnd{\text{sin }x}\)
            \item[Proiezione sulla \(k\)-esima componente:]\[\text{Pro}\rnd{k,x} = \text{se }k\leq l \text{ allora }x_k\]
            \item[Incrementa la \(k\)-esima componente:]\[\text{inc}\rnd{k,x} = \rnd{x_1, \ldots, x_k+1, \ldots, x_e}\]
            \item[Decrementa la \(k\)-esima componente:]\[\text{dec}\rnd{k,x} = \rnd{x_1, \ldots, x_k-1, \ldots, x_e}\]
            \item[Determina la lunghezza della sequenza:]\[\text{lung}\rnd{x}=l\]
            \item[\parbox{0.3\textwidth}{Associa al numero \(l\) il numero che rappresenta una sequenza di \(l\) zeri:}]\[\text{ze}\rnd{l} = \rnd{0,0,\ldots,0}\]
        \end{description}
    \end{multicols}
\end{theorem}
\clearpage
\section{Aritmetizzazione di programmi}
\begin{definition}[Aritmetizzazione di programmi]
    L'\textbf{aritmetizzazione} di Programmi è una funzione:
    \[
        \funcdef{\text{Cod}}{\text{Programmi}}{\N^+}
    \]
    tale che:
    \begin{enumerate}
        \item Cod è una corrispondenza biunivoca.
        \item Cod può essere computata con un programma PASCAL.
    \end{enumerate}
\end{definition}
\begin{example}[Aritmetizzazione di Programmi]
    Utilizzando le funzioni \(\ngle{x,y}\) (funzione coppia di Cantor), \(\ngle{x}_3\) (resto della divisione tra \(x\) e \(3\)) e \(x \div 3\) (quoto della divisione tra \(x\) e \(3\)):
    \begin{enumerate}
        \item Sia \textbf{Istruzioni} l'insieme delle istruzioni. Sia \(\funcdef{\text{Ar}}{\text{Istruzioni}}{\N}\) definito da:
        \begin{description}
            \item[Caso \(\text{istr}=R_k \leftarrow R_k + 1\):] \(\text{Ar}\rnd{\text{istr}} = 3\cdot k\) (multipli di 3)
            \item[Caso \(\text{istr}=R_k \leftarrow R_k - 1\):] \(\text{Ar}\rnd{\text{istr}} = 3\cdot k + 1\) (multipli di 3 più uno)
            \item[Caso \(\text{istr} = \text{IF }R_k = 0\text{ THEN GOTO }m\):]\(\text{Ar}\rnd{\text{istr}}=3\cdot \ngle{k,m}-1\) (multipli di 3 meno uno)
        \end{description}
        Ar è una corrispondenza biunivoca.
        \item La funzione \(\funcdef{\text{Cod}}{\text{Programmi}}{\N^+}\) è realizzata come segue: se \(\text{Cod}\rnd{P} = \text{istr}_1;\ldots;\text{istr}_s\) allora:
        \[
            \text{Cod}\rnd{P} = \ngle{\text{Ar}\rnd{\text{istr}_1}, \ngle{\ldots\ngle{\text{Ar}\rnd{\text{istr}_s},0}\ldots}}
        \]
        \textit{Cod} è allora una aritmetizzazione.
    \end{enumerate}
\end{example}
\begin{definition}[Numero di Gödel]
    Se \(j=\text{Cod}\rnd{P}\), diciamo che \(j\) è il numero di Gödel di \(P\), o che \(P\) è lo \(j\)-esimo programma nella numerazione di Gödel.
\end{definition}
\begin{multicols}{2}
    \begin{problem}
        \label{undefined_problem_one}
        Determinare il primo \(j\) tale per cui: \[\forall x: \varphi_j\rnd{x} = \bot\]
    \end{problem}
    \begin{solution}[Soluzione del problema \ref{undefined_problem_one}]
        Bisogna identificare il programma corrispondente al \(j\) più piccolo che sia indefinito: una possibile soluzione è il programma seguente:
        \[
            0: \text{IF }R_0 = 0\text{ THEN GOTO }0
        \]
        Il registro \(R_0\) (scelto perché è il registro con l'indice più piccolo) viene inizializzato a \(0\), per cui la condizione \(R_0 = 0\) è sempre vera, per cui il GOTO procede a tornare all'istruzione \(0\)-esima.
            
        Questo programma viene codificato a \(j=3\cdot\ngle{0,0}-1=3\cdot 1-1=2\): per essere sicuri che questo sia il \(j\) più piccolo strettamente positivo che porta a un \(\bot\), controlliamo se per \(j=1\) la soluzione è definita:
        \[
            0: R_0 \leftarrow R_0 +1
        \]
        Il programma così definito non da esito \(\bot\), per cui possiamo confermare che \(j=2\) è il più piccolo valore corrispondente a un programma con esito non definito.
    \end{solution}
    \begin{problem}
        \label{infinite_zero_problem}
        Determinare infiniti \(j_k\) tale per cui: \[\forall x: \varphi_{j_k}\rnd{x} = 0\]
    \end{problem}
    \begin{solution}[Soluzione del problema \ref{infinite_zero_problem}]
        Utilizzando il parametro \(k\) per generare infiniti programmi, basta non modificare il registro \(R_0\) e non generare deadlock per poter avere esito \(0\), quindi \(\forall k \in \N^{+}\) possiamo realizzare:
        \[
            0: R_k \leftarrow R_k + 1
        \]
        Quindi qualsiasi \(j\) multiplo di \(3\) corrisponde a un programma che ha come valore, per ogni ingresso, \(0\).
    \end{solution}
    \begin{problem}
        \label{intuitive_calculable_function}
        La funzione \(f\rnd{x} = \varphi_x\rnd{1}\) è "intuitivamente" calcolabile?
    \end{problem}
    \begin{solution}[Soluzione del problema \ref{intuitive_calculable_function}]
        Per mostrare che la funzione non è calcolabile è sufficiente identificare un \(x\) tale per cui il programma corrispondente, con input \(1\), non è calcolabile: abbiamo già identificato un tale programma nella soluzione del problema \ref{undefined_problem_one}: pertanto la funzione non è calcolabile.
    \end{solution}
\end{multicols}
\clearpage
\section{Programma interprete e funzione universale}
\begin{definition}[Interprete]
    Costruiamo \textit{int} utilizziamo macroistruzioni del linguaggio while: per l'esistenza di \(\funcdef{\text{Comp}}{\text{W-Programmi}}{\text{Programmi}}\) concluderemo che \textit{int} è esprimibile in linguaggio RAM.
    \begin{multicols}{2}
        Il nostro obbiettivo è di simulare con un programma while l'esecuzione di una RAM con programma \(P_j\), di numero di Gödel \(j\), sul dato \(x\). Poiché il programma \(P_j\) non contiene esplicitamente la variabile \(R_k\), se \(k\geq 1\), tali variabili permarranno azzerate nell'esecuzione del programma. Potremmo pertanto definire, relativamente all'esecuzione di \(P_j\), lo stato attraverso il contenuto dei registri \(L\) ed \(R_k\) \(\rnd{0\leq k \leq j+2}\).
        
        \textit{In realtà basterebbero i registri sino a \(R_5\) ma ci allarghiamo un poco.}
        
        Le variabili del programma \textit{int} contengono:
        
        \begin{description}
            \item[\(x_0\) contiene] \(\rnd{x_0, x_1, \ldots, x_{j+1}, x_{j+2}}\) cioè lo stato di memoria.
            \item[\(x_1\) contiene] \(l\), dove \(l\) è interpretato come contenuto corrente del registro \(L\).
            \item[\(x_2\) contiene] il dato \(x\)
            \item[\(x_3\) contiene] il codice \(j\) del programma \(P_j\)
            \item[\(x_4\) contiene] il codice dell'istruzione corrente da eseguire sulla macchina da simulare.
        \end{description}
    \end{multicols}
    \vspace{-1.5em}
    \begin{align*}
        &\parbox{0.3\textwidth}{Mette il dato \(x\) e il codice di programma \(j\) rispettivamente nei registri \(x_2\) ed \(x_3\)} \quad \begin{cases}
            x_2 = \text{sin}\rnd{x_1}\\
            x_3 = \text{des}\rnd{x_1}\\
        \end{cases} & \parbox{0.3\textwidth}{Proiettori}\\
        & \parbox{0.3\textwidth}{Il contenuto di \(x_0\) è posto essere \(\rnd{0, x, 0, 0, \ldots, 0}\)} \quad \begin{cases}
            x_0 = \underbrace{Z_e\rnd{x_3}}_{
                \parbox{0.25\textwidth}{Determina il numero di zero che vanno dopo \(x\): sono 20}
            }\\
            x_0 = \ngle{0, \ngle{x_3, x_0}}
        \end{cases} & \parbox{0.3\textwidth}{Questa coppia di istruzioni produce la sequenza \(\rnd{0,x,0,\ldots,0}\)}\\
        & \parbox{0.3\textwidth}{Simula l'inizializzazione di \(L\)}  \quad \begin{cases}
            x_1 = 1
        \end{cases} & \parbox{0.3\textwidth}{Ora è a tutti gli effetti una macchina RAM}\\
    \end{align*}
    \vspace{-3em}
    \begin{multicols}{2}
        Finché non si arriva alla condizione di terminazione \(\rnd{L=0 \Longleftrightarrow x_1 = 0}\) si desume dal contenuto di \(x_1\) l'istruzione corrente da simulare, se esiste (cioè se \(x_1 \leq \text{lung}\rnd{j}\)). In tal caso se ne mette il codice in \(x_4\), si decodifica e si simula la istruzione, dei due effetti di cambiamento di stato di memoria e di L.
        
        Il codice del procedimento è illustrato nella figura \ref{processo_simulato}.
        
        Una volta raggiunta la condizione di terminazione si lascia in \(x_0\) il contenuto finale di \(R_0\) nella macchina simulata:
        \[
            x_0 = \text{sin}\rnd{x_0}
        \]
        Poiché il programma utilizza esplicitamente \(9\) variabili e le macroistruzioni possono essere sostituite con istruzioni utilizzando al più 5 ulteriori variabili, concludiamo che esiste un programma \(\textit{int}_1\) scritto in linguaggio while che utilizza \(14\) variabili e tale che:
        \[
            \psi_{\textit{int}_1}\rnd{\ngle{x,y}} = \varphi_y\rnd{x}
        \]
        Detto \(\textit{int}_2\) il programma RAM tale che \(\textit{int}_2 = \text{Comp}\rnd{\textit{int}_1}\), vale che:
        \begin{enumerate}
            \item \(\textit{int}_2\) contiene al più \(16\) variabile \(R_k\)
            \item \(\varphi_{\textit{int}_2}\rnd{\ngle{x,y}} = \varphi_{\text{Comp}\rnd{\textit{int}_1}}\rnd{\ngle{x,y}} = \varphi_y\rnd{x}\)
        \end{enumerate}
        \vfill\null
        \columnbreak
        \begin{figure}
            \begin{description}
                \item[while \(x_1 \neq 0\) do] ~\\
                \begin{description}
                    \item[if \(x_1>\text{lung}\rnd{j}\)] ~\\
                        then \(x_1 = 0\)
                    \item[else] ~\\\(x_4=\text{Pro}\rnd{x_1, x_3}\)
                    \begin{description}
                        \item[if \(\ngle{x_4}_3 = 0\) then] \(
                            \begin{cases}
                                x_5 = x_4 \div 3\\
                                x_0 = \text{inc}\rnd{x_5, x_0}\\
                                x_1 = x_1 + 1
                            \end{cases}
                        \)
                        \item[if \(\ngle{x_4}_3 = 1\) then]\(
                            \begin{cases}
                                x_5 = x_4 \div 3\\
                                x_0 = \text{dec}\rnd{x_5, x_0}\\
                                x_1 = x_1 + 1
                            \end{cases}
                        \)
                        \item[if \(\ngle{x_4}_3 = 2\) then]\(
                            \begin{cases}
                                x_5 = x_4 \div 3 + 1\\
                                x_6 = \text{des}\rnd{x_5}\\
                                x_7 = \text{sin}\rnd{x_5}\\
                                x_8 = \text{Pro}\rnd{x_7, x_6}\\
                                \text{if }x_8 = 0 \begin{array}{l}
                                    \text{then }x_1 = x_0\\
                                    \text{else }x_1 = x_1 + 1
                                \end{array}
                                
                            \end{cases}
                        \)
                    \end{description}
                \end{description}
            \end{description}
            \caption{Processo di simulazione}
            \label{processo_simulato}
        \end{figure}
    \end{multicols}
    
\end{definition}
\begin{theorem}[Funzione universale]
    Facendo riferimento all'interprete \(\textit{int}_2\) definito precedentemente, dato il sistema di programmazione RAM \(\crl{\varphi_j}\), esiste un indice \(u = \text{Cod}\rnd{\textit{int}_2}\) tale che:
    \[
        \forall x \forall y\quad \varphi_u\rnd{\ngle{x,y}} = \varphi_y\rnd{x}
    \]
    La funzione parziale \(\varphi_u\) è detta \textbf{funzione universale} per \(\crl{\varphi_j}\).
\end{theorem}

\section{Eliminazione del GOTO}
\begin{theorem}[Da programma RAM a While]
    Per ogni programma RAM \(P\) esiste un programma while \(W\) contenente al più 14 variabili \(x_k\) tale che:
    \[
        \forall x \quad \varphi_P\rnd{x} = \varphi_W\rnd{x}
    \]
    Lo stesso risultato può essere espresso come:
    \[
        \text{Funzioni}\rnd{\text{RAM}} \subseteq \text{Funzioni}\rnd{\text{while}}
    \]
\end{theorem}
\begin{proof}[Da programma RAM a While]
    Sia \(j=\text{Cod}\rnd{P}\) il numero di Gödel di \(P\). Consideriamo il seguente programma while con macroistruzioni:
    \[
        \text{begin }x_0 = j; x_1 = \ngle{x_1, x_0}; x_0 = 0; x_0 = \varphi_{\textit{int}_1}\rnd{x_1}\text{ end}
    \]
    dove:
    \begin{enumerate}
        \item La macroistruzione \(x_0 = j\) sta per: \(
            \text{begin }\underbrace{x_0 = x_0 +1;x_0 = x_0 +1;\ldots;x_0 = x_0 +1}_{j\text{ volte}}\text{ end}
        \)
        \item La macroistruzione \(x_0 = \varphi_{\textit{int}_1}\rnd{x_1}\) è realizzata dal programma \(\textit{int}_1\).
    \end{enumerate}
    Siccome \(\textit{int}_1\) usa \(14\) variabili (compresa \(x_0\)) e su \(x_0\) non ci sono effetti collaterali, il precedente programma abbrevia un programma while \(W\) che utilizza 14 variabili. Inoltre:
    \[
        \psi_{W}\rnd{x} = \psi_{\textit{int}_1}\rnd{\ngle{x,j}} = \varphi_j\rnd{x} = \varphi_P\rnd{x}
    \]
\end{proof}
\clearpage
\chapter{Le funzioni ricorsive parziali}
\begin{multicols}{2}
    \begin{definition}[Composizione]
        Se \(h\rnd{x_1, \ldots, x_m}\) è una funzione a \(m\) argomenti e \(g_1\rnd{\bmx}, \ldots, g_m\rnd{\bmx}\) sono funzioni a \(n\) argomenti, la composizione di \(h\) e \(g_1, \ldots, g_m\) è la funzione \(f\) in \(n\) argomenti definita:
        \[
            f\rnd{\bmx} = h\rnd{g_1\rnd{\bmx},g_2\rnd{\bmx}, \ldots, g_m\rnd{\bmx}}
        \]
    \end{definition}
    \begin{definition}[Ricorsione primitiva]
        Se \(h\rnd{y,z,\bmx}\) è una funzione a \(n+2\) argomenti e \(g\rnd{\bmx}\) una funzione a \(n\) argomenti, la ricorsione primitiva applicata a \(h\) e \(g\) determina una funzione \(\text{RP}\rnd{h\mid g} = f\rnd{y,\bmx}\) in \(n+1\) argomenti definita da:
        \[
            \text{RP}\rnd{y,\bmx} = \begin{cases}
                g\rnd{\bmx} & \text{se } y=0\\
                h\rnd{\text{RP}\rnd{y-1, \bmx}, y-1, \bmx} & \text{se }y>0
            \end{cases}
        \]
    \end{definition}
    \begin{definition}[Minimalizzazione]
        L'operazione di minimalizzazione applicato su una funzione ad \(n+1\) argomenti \(\f{\bmx, y}\) restituisce se esiste il più piccolo valore dell'\(n+1\)-esimo elemento che annulla il valore della funzione.
        \[
            \min\rnd{f}\rnd{\bmx} = \begin{cases}
                y & \text{se }y=\argmin_{y} f\rnd{\bmx, y} = 0\\
                \bot & \text{altrimenti}
            \end{cases}
        \]
        Essa è una funzione parziale.
    \end{definition}
    \begin{definition}[Funzioni base]
        Le funzioni base sono:
        \begin{description}
            \item[Annullamento:] \(O^n\rnd{x_1, x_2, \ldots, x_n}=0\) 
            \item[Successore:]\(S\rnd{x}=x+1\)
            \item[Proiezione:] \(\text{Pro}^n_k\rnd{x_1, \ldots, x_k, \ldots, x_n} = x_k\)
        \end{description}
    \end{definition}
    \begin{definition}[Funzioni ricorsive parziali]
        La classe delle \textbf{funzioni ricorsive parziali} \(P_f\) è la più piccola classe contenente le funzioni base e chiusa rispetto a \textit{composizione}, \textit{ricorsione primitiva} e \textit{minimalizzazione}.
        
        Indicheremo con \(P_f^n\) la classe delle funzioni ricorsive parziali in \(n\) argomenti.
    \end{definition}
    \begin{observation}[Come dimostrare che una proprietà vale per tutte le funzioni ricorsive parziali]
        Data una proprietà \(P\), per dimostrare che essa vale per tutte le \textit{funzioni ricorsive parziali} \(P_f\), è sufficiente seguire il seguente schema di induzione:
        \begin{enumerate}
            \item \(P\) vale per tutte le \textbf{funzioni base}.
            \item \begin{enumerate}
                \item Se \(P\) vale per \(h, g_1, \ldots, g_m\) allora vale anche per la \textbf{composizione}.
                \item Se \(P\) vale per \(h\) e \(g\) allora vale anche per la funzione definita per \textbf{ricorsione primitiva}.
                \item Se \(P\) vale per \(g\), allora vale anche per la funzione definita per \textbf{minimalizzazione}.
            \end{enumerate}
        \end{enumerate}
    \end{observation}
    \begin{definition}[Funzioni ricorsive totali]
        Chiamiamo \(T_f\) la classe di funzioni totali \(f\in P_f\), chiamandola classe delle \textbf{funzioni ricorsive totali}. 
        
        Indicheremo con \(T_f^n\) la classe delle funzioni ricorsive totali in \(n\) argomenti.
    \end{definition}
\end{multicols}
\clearpage
\section{Da funzioni ricorsive parziali a programmi while}
\begin{multicols}{2}
    Vogliamo determinare la relazione tra l'insieme delle funzioni realizzabili in linguaggio while e delle funzioni appartenenti alla classe delle \(P_f\). Per poter realizzare funzioni while a \(n\) argomenti procediamo ad introdurre dei vettori.
    \begin{definition}[Vettore di dimensione \(n\) a componenti intere]
        Una possibile rappresentazione dei vettori è:
        \begin{align*}
            &\sqr{x_1} = x_1 &\\
            &\underbrace{\sqr{x_1, x_2} = \ngle{x_1, x_2} - 1}_{\text{dove \(\sqr{,}\) realizza un isomorfismo }\funcdef{\sqr{,}}{\N \times \N}{\N}}\\
            &\underbrace{\sqr{x_1, x_2, x_3} = \sqr{x_1, \sqr{x_2, x_3}}}_{\text{dove \(\sqr{,,}\) realizza un isomorfismo }\funcdef{\sqr{,,}}{\N \times \N\times \N}{\N}}\\
            & \ldots
        \end{align*}
        Definiamo le funzioni computabili da programmi while a \(n\) argomenti come il sistema \(\crl{\psi_P^n}\), dove \(\psi_P^n = \psi_P\rnd{\sqr{x_1, \ldots, x_n}}\). In sostanza, l'indice \(n\) in alto funziona come una dichiarazione di tipo delle variabile in ingresso.
    \end{definition}
    \begin{theorem}[Funzioni ricorsive parziali e programmi while]
        Ogni funzione \(f \in P_f\) è computabile da programmi while.
    \end{theorem}
    \begin{proof}[Funzioni ricorsive parziali e programmi while]
        Per quanto riguarda le funzioni base, esse sono computabili da programmi while con una immediata verifica.
        
        Procediamo quindi verificare i rimanenti tre punti:
        \begin{description}
            \item[Composizione:] Sia \(h\rnd{x_1, \ldots, x_m} = \psi_W^m\) per un programma while \(W\), e siano \(g_k\rnd{\bmx} = \psi^n_{B_k}\) per programmi while \(B_k\), con \(1 \leq k \leq m\). Il seguente programma calcola allora la composizione \(h\rnd{g_1, \ldots, g_m}\):
            \begin{description}
                \item begin
                \begin{description}
                    \item \(x_0 = \psi_{B_m}\rnd{x_1};\)
                    \item \(x_0 = \sqr{x_0, \psi_{B_{m-1}}\rnd{x_1}};\)
                    \item \(\vdots\)
                    \item \(x_0 = \sqr{x_0, \psi_{B_{m}}\rnd{x_1}};\)
                    \item \(x_0 = \psi_{W}\rnd{x_0};\)
                \end{description}
                \item end
            \end{description}
            \item[Ricorsione primitiva:] Sia \(h\rnd{y,z,\bmx} = \psi_W^{n+2}\) per un programma while \(W\) e sia \(g\rnd{\bmx} = \psi_B^n\) per un programma while \(B\). Allora la funzione ottenuta per ricorsione primitiva da \(h\) e \(g\) è calcolata dal programma:
            \begin{description}
                \item begin
                \begin{description}
                    \item \(x_4 = \text{Pro}_{1}\rnd{x_1};\)
                    \item \(x_1 = \text{des}\rnd{x_1};\)
                    \item \(x_0 = \psi_B\rnd{x_1};\)
                    \item while \(x_3 \neq x_4\) do:
                    \begin{description}
                        \item \(x_0 = \psi_W\rnd{\sqr{x_0, x_3, x_1}}\)
                        \item \(x_3 = x_3 + 1\)
                    \end{description}
                \end{description}
                \item end
            \end{description}
            Si noti che il programma è iterativo.
            \item[Minimalizzazione:] Supponiamo che esista un programma \(W\) che calcola \(g\), cioè \(g = \psi^{n+1}_W\). Allora il seguente programma while calcola la funzione \(f\rnd{\bmx}\) ottenuta applicando a \(g\) l'operatore di minimalizzazione:
            \begin{description}
                \item begin
                \begin{description}
                    \item \(x_2 = \psi_W\rnd{\sqr{0, x_1}};\)
                    \item while \(x_3 \neq 0\) do:
                    \begin{description}
                        \item \(x_0 = x_0 + 1\)
                        \item \(x_2 = \psi_W\rnd{\sqr{x_0, x_1}}\)
                    \end{description}
                \end{description}
                \item end
            \end{description}
        \end{description}
    \end{proof}
\end{multicols}
\clearpage
\section{Da programmi while a funzioni ricorsive parziali}
Poniamoci ora il problema opposto: sono le funzioni computate da programmi while ricorsive parziali?

Per semplificare la notazione, ricordiamo che ad ogni comando \(C\) è associata una funzione parziale \(\funcdef{\ssqr{C}}{\N^{21}}{\N^{21}}\). D'altro lato, usando le funzioni coppia \(\sqr{,}\), abbiamo mostrato che c'è un isomorfismo \(\N^{21} \simeq \N\). Potremo allora interpretare la semantica \(\ssqr{C}\) come una funzione parziale \(\funcdef{f_C}{\N}{\N}\), definita come segue:
\begin{enumerate}
    \item All'ingresso \(x\) associamo il vettore a \(21\) componenti rappresentato da \(x\).
    \item Trasformiamo tale vettore in \(\sqr{y_1, \ldots, y_{21}}\) con la funzione \(\ssqr{C}\).
    \item Otteniamo l'uscita \(y = f_C\rnd{x}\) interpretando tale vettore come numero.
\end{enumerate}

\begin{theorem}[Da programmi while a funzioni ricorsive parziali]
    Se \(C\) è un comando del linguaggio while, allora \(f_C \in P_f\).
\end{theorem}
\begin{proof}[Da programmi while a funzioni ricorsive parziali]
    Se \(P\) è un programma, \(\psi_P\rnd{x} = \text{Pro}\rnd{1, f_P\rnd{\sqr{0, x, 0, \ldots, 0}}}\). Se dimostriamo che \(f_P\) è ricorsiva parziale, allora anche \(\psi_P\) lo è, in quanto ottenuta per composizione di funzioni ricorsive parziali.
    \begin{enumerate}
        \item Se \(A\) è un assegnamento, allora \(f_A \in P_f\) con verifica immediata.
        \item \begin{enumerate}
            \item Sia \(C \equiv \text{begin }C_1, \ldots, C_m\text{ end}\) un comando e \(f_{C_k} \in P_f\), con \(1\leq k \leq m\). Allora \(f_C = f_{C_m} \circ \ldots \circ f_{C_1} \in P_f\), in quanto ottenuto per composizione di funzioni di \(P_f\).
            \item Sia \(C \equiv \text{while }x_k \neq 0 \text{ do }C_1\) e sia \(f_{C_1} \in P_f\). Ricordando la semantica:
            \[
                f_C\rnd{x} = f^{\mu e}_{C_1}\rnd{x}^{\text{Pro}\rnd{k, f^{e}_{C_1}\rnd{x}}=0}
            \]
            Consideriamo la funzione \(S\rnd{y,x} = f^y_{C_1}\rnd{x}\). Dall'identità:
            \[
                f^y_{C_1} = f^1_{C_1} \circ f^{y-1}_{C_1} \text{ con }y>0
            \]
            segue che:
            \[
                S\rnd{y,x} = \begin{cases}
                    x & \text{se }y=0\\
                    f^{1}_{C_1}\rnd{S\rnd{y-1, x}} & \text{altrimenti}
                \end{cases}
            \]
            Sappiamo che \(S\rnd{y,x} \in P^2_f\) in quanto definita per ricorsione primitiva di funzioni in \(P_f\). Allora \(\text{Pro}\rnd{k, S\rnd{y,x}} \in P_f\), perché composizione di funzioni di \(P_f\), e \(e\rnd{x} = \mu y \rnd{\text{Pro}\rnd{k, S\rnd{y,x}}} \in P_f\), in quanto definita per minimalizzazione di una funzione in \(P_f\).
            
            \(S\rnd{e\rnd{x}, x} \in P_f\) perché definita come composizione di funzione in \(P_f\), e quindi \(f_C\rnd{x} \in P_f\), poiché \(f_C\rnd{x} = S\rnd{e\rnd{x}, x}\).
        \end{enumerate}
    \end{enumerate}
\end{proof}
\begin{theorem}[Equivalenza tra insiemi di funzioni]
\[
    \text{Funzioni}\rnd{\text{RAM}} = \text{Funzioni}\rnd{\text{while}} = \text{Funzioni}\rnd{\text{PASCAL}} = P_f
\]
Tutti i formalismi che abbiamo presentato permettono il calcolo della stessa classe di funzioni: le \textbf{funzioni ricorsive parziali}.
\end{theorem}
\begin{theorem}[Tesi di Church]
    La classe delle funzioni \textbf{intuitivamente calcolabili} (calcolabili in modo automatico) è la classe delle \textbf{funzioni ricorsive parziali.}
\end{theorem}

\chapter{Esistenza di problemi non decidibili}
\begin{multicols}{2}
    \begin{definition}[Problema]
        Descriviamo un problema come una coppia:
        \[
            \ngle{\ngle{\text{istanza}}, \ngle{\text{questione}}}
        \]
        dove \(\ngle{\text{istanza}}\) è una variabile su un dato dominio \(D\), \(\ngle{\text{questione}}\) un predicato su \(D\).
    \end{definition}
    \begin{definition}[Problema decidibile]
        Diremo che un problema \(M\) è \textbf{decidibile} se esiste una funzione ricorsiva totale \(\funcdef{\Phi}{D}{\crl{0,1}}\) per cui:
        \[
            \varphi\rnd{x} = \begin{cases}
                1 & \text{se la condizione \(p\) è verificata su \(x\)}\\
                0 & \text{altrimenti}
            \end{cases}
        \]
        Richiediamo cioè che la funzione caratteristica dell'estensione di \(p\) sia ricorsiva totale.
    \end{definition}
    \begin{definition}[Problema dell'arresto]
        Poniamoci il problema di decidere l'arresto dell'esecuzione del programma \(P\) sul dato \(x\):
        \begin{description}
            \item[Problema:] Arresto per \(P\), \(\rnd{AP}\)
            \item[Istanza:] Un intero \(x\)
            \item[Questione:] È \(\varphi_P\rnd{x} \neq \bot\)?
        \end{description}
        È la sequenza di esecuzione del programma \(P\) sul dato \(x\) finita?
    \end{definition}
    \begin{theorem}[Problema dell'arresto]
        \(\rnd{AP}\) non è decidibile.
    \end{theorem}
    \begin{proof}[Problema dell'arresto]
        Supponiamo per assurdo che \(\rnd{AP}\) sia decidibile.
        
        Esiste allora una funzione ricorsiva totale \(\Phi_{AP}\) tale che:
        \[
            \Phi_{AP}\rnd{x} = \begin{cases}
                0 & \text{se } \varphi_{P}\rnd{x} = \bot\\
                1 & \text{altrimenti}
            \end{cases}
        \]
        Allora anche la seguente funzione è ricorsiva totale:
        \[
            \psi\rnd{x} = \begin{cases}
                0 & \text{se } \Phi_{AP}\rnd{x} = 0\\
                1 + \varphi_P\rnd{x} & \text{altrimenti}
            \end{cases}
        \]
        Esisterebbe quindi un programma RAM, con un numero di Gödel \(e\), che computa \(\psi\), cioè: \(\forall x \quad \varphi_e\rnd{x} = \psi\rnd{x}\).
        
        Vale allora la seguente catena:
        \begin{align*}
            \psi\rnd{e} &= \underbrace{\varphi_e\rnd{e} = \varphi_P\rnd{e}}_{\text{\(e=P\) è un possibile assegnamento}}\\ &= \begin{cases}
                0 & \text{se }\Phi_{AP}\rnd{e} = 0\\
                1 + \varphi_P\rnd{e}
            \end{cases}
        \end{align*}
        \(\Phi_{AP}\rnd{e}\) non può essere \(1\), altrimenti sarebbe \(\varphi_P\rnd{e} = 1 + \varphi_P\rnd{e}\).
        
        Poiché \(\Phi_{AP}\) è totale e prende valori in \(\crl{0,1}\), deve essere \(\Phi_{AP}\rnd{e} = 0\).
        
        Se \(\Phi_{AP}\rnd{e} = 0\), dalla catena precedente segue che \(\varphi_P\rnd{e} = 0\), mentre dalla definizione segue che \(\varphi_P\rnd{e} = \bot\), da cui l'assurdo.
    \end{proof}
\end{multicols}
\clearpage
\section{Funzione del linguaggio di programmazione per il linguaggio RAM}
\begin{multicols}{2}
    \begin{definition}[Funzione del linguaggio di programmazione]
        La legge che ad ogni \(P\) e ad ogni \(\bar{y}\) associa \(P_{\bar{y}}\) viene chiamata \(S^1_1\) \textbf{funzione del linguaggio di programmazione} ed è una funzione ricorsiva totale.
    \end{definition}
    \begin{theorem}[\(S_1^1\) Funzione del linguaggio RAM]
        Dato il sistema di programmazione RAM \(\crl{\varphi_i}\), esiste una funzione ricorsiva totale \(S^1_1\rnd{i,y}\) tale che:
        \[
            \forall i \forall y \forall x\quad \varphi_{S^1_1\rnd{i,y}}\rnd{x} = \varphi_i\rnd{\ngle{x,y}}
        \]
        Significa che dato un programma \(P\) che lavora su due variabili, è sempre possibile generare automaticamente un programma \(P'\) che lavora su una variabile fissando l'altra.
    \end{theorem}
    \begin{proof}[\(S_1^1\) Funzione del linguaggio RAM]
        Sia \(P_i\) il programma di numero di Gödel \(i\), che computa la funzione \(\varphi_i\). Fissato un \(y \in \N\), sia \(\bar{P}_{i,y}\) il segmento programma RAM, scritto usando macroistruzioni:
        \[
            \bar{P}_{i,y} = \underbrace{R_0 \leftarrow R_0 +1; \ldots; R_0 \leftarrow R_0 +1}_{y\text{ volte}};R_1 \leftarrow \ngle{R_1, R_0}; R_0 \leftarrow 0; P_i
        \]
        Si osserva immediatamente che la funzione computata da \(\bar{P}_{i,y}\) su ingresso \(x\) è \(\varphi_i\rnd{\ngle{x,y}}\). Basta allora porre:
        \[
            S^1_1\rnd{i,y} = \text{Cod}\rnd{\bar{P}_{i,y}}
        \]
        Non è quindi difficile fornire un algoritmo che, dato \(i\) e \(y\), dà in uscita il valore \(S^1_1\rnd{i,y}\).
        
        \(S^1_1\) è allora una funzione ricorsiva totale.
    \end{proof}
    \begin{theorem}[\(S_n^m\) Funzione del linguaggio RAM]
        Dato il sistema di programmazione RAM \(\crl{\varphi_i}\) esiste una funzione ricorsiva totale a \(n+1\) variabili \(S^m_n\rnd{i,y}\) tale che:
        \[
            \forall i \forall \bmy \forall \bmx \quad \varphi_{S^m_n\rnd{i,y}}\rnd{\bmx} = \varphi_i\rnd{\bmx, \bmy}
        \]
        Questo vale anche per altri linguaggi di programmazione.
    \end{theorem}
\end{multicols}
\chapter{Sistema di programmazione accettabile}

\begin{multicols}{2}
    \begin{observation}[Come costruire un sistema di programmazione accettabile]
        Identificheremo con \(\N\) il linguaggio di programmazione. I requisiti che richiederemo sono:
        \begin{enumerate}
            \item Un sistema di programmazione deve contenere programmi per tutte le funzioni ricorsive parziali di un argomento \(\rnd{P^1_f}\).
            \item Deve esistere un programma universale \(u\) che, ricevuta in ingresso la coppia \(\ngle{x,y}\), simula il programma \(y\) sul dato \(x\).
            \item Deve essere possibile scambiare argomenti e parametri in modo automatico, per il teorema \(S^m_n\).
        \end{enumerate}
    \end{observation}
    \begin{definition}[Sistema di programmazione accettabile]
        Un sistema di programmazione è detto \textbf{accettabile} se rispetta le seguenti 3 proprietà:
        \begin{enumerate}
            \item È concorde con la tesi di Church: permette di calcolare esattamente \(P_f\), la classe delle funzioni ricorsive parziali.
            \item Ammette interprete universale.
            \item Ammette la funzione del linguaggio di programmazione descritta nel teorema \(S^1_1\).
        \end{enumerate}
    \end{definition}
    \begin{definition}[Traduzione]
        Dati due sistemi di programmazione \(\crl{\varphi_i}\) e \(\crl{\psi_i}\), una \textbf{traduzione} \(t\) da \(\crl{\varphi_i}\) a \(\crl{\psi_i}\) è una funzione \(\funcdef{t}{\N}{\N}\) tale che:
        \begin{enumerate}
            \item \(t\) è ricorsiva totale
            \item \(\forall i\in\N: \psi_{t\rnd{i}}=\varphi_i\)
        \end{enumerate}
    \end{definition}
    \begin{definition}[Quines]
        Si tratta di una classe di programmi che stampano sé stessi. Un sistema di programmazione accettabile ammette sempre un quine.
    \end{definition}
    \begin{theorem}[Teorema di ricorsione]
        Sia \(\funcdef{t}{\N}{\N}\) una funzione ricorsiva totale, e sia \(\crl{\varphi_j}\) un sistema di programmazione. Esiste allora un "programma" \(n \in \N\) tale che: \(\varphi_n = \varphi_{t\rnd{n}}\).
        
        In altre parole, fissato un sistema di programmazione accettabile, per qualsiasi funzione ricorsiva totale \(t\) esiste un programma la cui semantica non cambia sotto \(t\).
    \end{theorem}
    \begin{proof}[Teorema di ricorsione]
        Per dimostrare il teorema di ricorsione, si prenda la particolare funzione \(\varphi_{\varphi_i\rnd{i}}\rnd{x}\) e si applichi ad essa per due volte la definizione di interprete universale:
        \begin{align*}
            \varphi_{\varphi_i\rnd{i}}\rnd{x} &= \varphi_{\varphi_u\rnd{i,i}}\rnd{x}\\
            &= \varphi_u\rnd{x, \varphi_u\rnd{i,i}}\\
            &= \f{x,i}
        \end{align*}
        La funzione ottenuta è una composizione di \(\varphi_u\) su sè stessa ed è quindi una \textbf{funzione ricorsiva parziale}. Siccome \(\crl{\varphi_i}\) è un sistema di programmazione accettabile, esisterà un particolare programma \(e \in \N\) tale che \(\varphi_e\rnd{x,i} = f\rnd{x,i}\) e allora per il teorema \(S^1_1\) possiamo scrivere:
        \[
            \varphi_e\rnd{x,i} = \varphi_{S_1^1\rnd{e,i}}\rnd{x} = \varphi_{\varphi_i\rnd{i}}\rnd{x}
        \]
        Per costruzione, si ha quindi che \(t\rnd{S_1^1\rnd{e,i}} \in T_f\) poiché essa risulta ottenuta come composizione di funzioni ricorsive totali, e pertanto sarà calcolata in particolare da un programma \(m\), cioè:
        \[
            t\rnd{S_1^1\rnd{e,i}} = \varphi_m\rnd{i}
        \]
        Allora si dimostra che \(n=S_1^1\rnd{e,m}\) mantiene la semantica sotto \(t\) ricavando:
        \begin{align*}
            \varphi_n\rnd{x} &= \varphi_{S^1_1\rnd{e,m}}\rnd{x}\\
            &= \varphi_e\rnd{x,m}\\
            &= \varphi_{\varphi_m\rnd{m}}\rnd{x}
        \end{align*}
        Ed inoltre:
        \begin{align*}
            \varphi_{t\rnd{n}}\rnd{x} &= \varphi_{t\rnd{S_1^1\rnd{e,m}}}\rnd{x}\\
            &= \varphi_{\varphi_m\rnd{m}}\rnd{x}
        \end{align*}
        da cui la tesi.
    \end{proof}
\end{multicols}
\chapter{Insiemi ricorsivi e ricorsivamente numerabili}
\begin{multicols}{2}
\begin{definition}[Funzione caratteristica]
    La \textbf{funzione caratteristica} \(\funcdef{X_A}{\N}{\crl{0,1}}\) di un insieme \(A \subseteq \N\) è la funzione:
    \[
        X_A\rnd{x} = \begin{cases}
            1 & \text{se } x \in A\\
            0 & \text{altrimenti}
        \end{cases}
    \]
\end{definition}
\begin{definition}[Insieme ricorsivo]
    Intuitivamente un sottoinsieme \(A\subseteq \N\) è ricorsivo se e solo se esiste un procedimento finito che permette di decidere, per ogni \(x \in \N\), se \(x \in A\) oppure \(x \not\in A\).
    
    Un insieme \(A\) si dice \textbf{ricorsivo} se e solo se la sua funzione caratteristica \(X_A\) è \textbf{ricorsiva totale}.
\end{definition}
\begin{definition}[Relazione ricorsiva]
    Data una relazione \(R \subseteq \N \times \N\), una relazione \(R\) sarà detta ricorsiva se la sua funzione caratteristica \(X_R\rnd{x,y}\) è ricorsiva totale.
\end{definition}
\begin{observation}[Insieme ricorsivo e problema decidibile]
    La nozione di insieme ricorsivo coincide con quella di problema decidibile.
\end{observation}
\begin{definition}[Insieme ricorsivamente numerabile]
    Intuitivamente, diremo che un insieme \(A\) è ricorsivamente numerabile se esiste un procedimento finito che permette di elencare gli elementi di \(A\) "uno dietro l'altro".
    
    Più formalmente, un insieme \(A\subseteq \N\) è detto \textbf{ricorsivamente numerabile} se o \(A = \emptyset\) o \(A\) è l'immagine di una funzione ricorsiva totale \(\funcdef{f}{\N}{\N}\). 
\end{definition}
\begin{definition}[Insieme parzialmente decidibile]
    Un insieme ricorsivamente numerabile è detto anche \textbf{parzialmente decidibile}, perché, per decidere se un elemento \(y \in A\), basta enumerare fino fino al valore \(x\) per cui \(y = f\rnd{x}\). Naturalmente, tale metodo è parziale perché in generale non è possibile decidere se \(y\not\in A\).
\end{definition}
\begin{theorem}[Teorema: Insieme ricorsivamente numerabile]
    Sia \(A\subseteq\N\). Allora le seguenti tre affermazioni sono equivalenti:
    \begin{enumerate}
        \item \(A\) è ricorsivamente numerabile.
        \item A è il dominio di quale funzione ricorsiva parziale \(f \in P_f\)
        \item Esiste una relazione ricorsiva \(R\subseteq\N\times\N\) per cui:
        \[
            A = \crl{x\mid \exists y: \;\rnd{x,y} \in R}
        \]
    \end{enumerate}
\end{theorem}
\begin{proof}[Teorema: Insieme ricorsivamente numerabile]
    Per provare la correttezza del teorema, si procederà mostrando l'esistenza di una relazione di implicazione circolare tra le tre affermazioni.
    
    \textbf{Intanto è banale osservare che \(\rnd{1}\Rightarrow\rnd{2}\):} è sempre possibile costruire un programma (che quindi appartiene al set delle funzioni ricorsive parziali) se l'insieme \(A\) è ricorsivamente numerabile.
    
    \textbf{Per mostrare che \(\rnd{2}\Rightarrow\rnd{3}\)}, si prenda \(A = \text{Dom}_f\) per qualche \(f \in P_f\). Allora, per la \textbf{tesi di Church}, esisterà in particolare un programma \(P\) che calcola \(f\): \(\varphi_P\rnd{x} = \f{x}\).
    
    Consideriamo quindi la relazione binaria, che sappiamo essere ricorsiva:
    \[
        R_P = \crl{\rnd{x,y} \mid P\rnd{x} \neq \bot \text{ in \(y\) passi}}
    \]
    Allora \(A\) sarà l'insieme degli elementi per i quali \(P\rnd{x} \neq \bot\) termina in un numero finito di passi, cioè:
    \[
        A = \crl{x \mid \exists y: \rnd{x,y} \in R_P}
    \]
    Infatti, preso \(x \in \text{Dom}_f\), si ha che \(P\rnd{x}\neq \bot\) e quindi esisterà un valore \(\bar{y}\) per cui \(\rnd{x,\bar{y}} \in R_P\) e di conseguenza \(x\in A\) e viceversa: quindi \(A = \text{Dom}_f\).
    
    \textbf{Infine mostriamo che \(\rnd{3}\Rightarrow\rnd{1}\)}, cioè che preso \(A = \crl{x \mid \exists y: \rnd{x,y} \in R}\), per qualche relazione binaria \(R\) ricorsiva, allora \(A = \text{Im}_f\), per qualche funzione \(f \in T_f\).
    
    Se \(A = \emptyset\) allora sarebbe ricorsivamente numerabile per definizione. Viceversa, fissiamo un \(a \in A\) e definiamo:
    \[
        f\rnd{n} = \begin{cases}
            \text{sin}\rnd{n} & \text{se } \rnd{\text{sin}\rnd{n}, \text{des}\rnd{n}} \in R\\
            a & \text{altrimenti}
        \end{cases}
    \]
    Si noti che \(f \in T_f\) poiché \(R\) è ricorsiva per ipotesi e pertanto è sempre possibile decidere l'appartenenza di \(\rnd{\text{sin}\rnd{n}, \text{des}\rnd{n}}\). Inoltre l'insieme \(A = \text{Im}_f\). Infatti \(\forall x \in \text{Im}_f \cup \crl{a} \Rightarrow x \in A\) per definizione.
    
    Viceversa, se \(x \in A\) allora \(\exists y: \rnd{x,y} \in R\) e conseguentemente per \(n = \ngle{x,y}\) si ha che \(f\rnd{n} = x\) e quindi \(x \in \text{Im}_f\), che conclude la dimostrazione.
\end{proof}
    \begin{theorem}[Insieme ricorsivo e ricorsivamente numerabile]
        Sia \(A \subseteq \N\) un insieme ricorsivo. Allora \(A\) è ricorsivamente numerabile.
    \end{theorem}
    \begin{theorem}[Insieme ricorsivo e suo complemento]
        Sia \(B \subseteq \N\) un insieme ricorsivamente numerabile e sia \(B^C\) il suo complemento. Se anche \(B^C\) è ricorsivamente numerabile, allora \(B\) è ricorsivo.
    \end{theorem}
\end{multicols}
\chapter{Il teorema di Rice}
\begin{multicols}{2}
    \begin{definition}[Insieme che rispetta le funzioni]
        Dato un sistema di programmazione accettabile \(\rnd{\varphi_i}\), un insieme \(I\subseteq \N\) è detto \textbf{rispettare le funzioni} se e solo se:
        \[
            \forall i \in I \forall j: \varphi_j = \varphi_i \Leftrightarrow j \in I
        \]
        Detto in altre parole, \(I\) rispetta le funzioni se, contenendo un programma \(i\), allora contiene tutti i programmi che calcolano la funzione \(\varphi_i\).
    \end{definition}
    \begin{theorem}[Teorema di Rice]
        Sia \(I \subseteq \N\) un insieme tale che \textbf{rispetti le funzioni}. Allora \(I\) è \textbf{ricorsivo} se e solo se \(I = \emptyset\) o \(I=\N\).
        
        Detto in altri termini, il teorema stabilisce che un insieme che rispetta le funzioni è ricorsivo solamente in casi banali: se \(I\) è ricorsivo, o tutto \(\N\) è dentro all'insieme \(I\) o niente è dentro e \(I = \emptyset\).
    \end{theorem}
    \begin{proof}[Teorema di Rice]
        Per dimostrare il teorema si procede per assurdo: sia \(I\) un insieme ricorsivo e si supponga che \(I \neq \emptyset \neq \N\). Allora esisteranno due elementi \(a\) e \(b\) tali che \(a \in I\) e \(b \not\in I\). Dunque è possibile definire una traduzione:
        \[
            t\rnd{n} = \begin{cases}
                a & \text{se }n \not\in I\\
                b & \text{se }n \in I
            \end{cases}
        \]
        Se \(I\) è ricorsivo, allora l'appartenenza ad \(I\) può essere nettamente decisa e quindi la funzione \(t\) è ricorsiva totale. Sotto questa ipotesi trova quindi applicazione il \textbf{teorema di ricorsione}, in base al quale esiste certamente un \(\bar{n}\) per il quale \(\varphi_{\bar{n}} = \varphi_{t\rnd{\bar{n}}}\).
        
        Dunque, se \(\bar{n} \in I\) si ha che \(\varphi_{t\rnd{\bar{n}}} = \varphi_b\) ma \(b \not\in I\). Viceversa per \(\bar{n} \not\in I\) otteniamo \(\varphi_{t\rnd{\bar{n}}} = \varphi_a\) con \(a \in I\).
        
        Quindi \(I\) non può essere ricorsivo.
    \end{proof}
    \begin{observation}[Conseguenza del teorema di Rice]
        Una delle conseguenze del teorema di Rice è che non risulta possibile dimostrare in modo automatico la correttezza dei programmi: cioè, dato un programma \(i\), non esiste un programma \(T\) che su input \(i\) fornisce in output il valore \(1\) se \(\varphi_i=f\) e \(0\) se \(\varphi_i \neq f\), dove \(f\) è una specifica funzione in base alla quale si vuole testare la correttezza del programma. 
        
        Infatti, decidere la correttezza di \(i\) equivarrebbe a decidere l'appartenenza all'insieme:
        \[A = \crl{i \mid \varphi_i = f}\]
        Tuttavia il teorema di Rice impone che tale insieme non sia ricorsivo: infatti \(A\) rispetta le funzioni per costruzione ed inoltre \(A\) non è l'insieme vuoto (poiché almeno \(f = \varphi_i \in A\)) ed in più esiste sempre almeno un programma \(j\) per cui \(\varphi_j \neq f\). Pertanto \(A\) non è decidibile, il che equivale a dire che \(T\) non esiste.
    \end{observation}
\end{multicols}
\clearpage
\begin{problem}[Esercizio riassuntivo]
    Dato un sistema di programmazione accettabile \(\crl{\varphi_i}\):
    \begin{enumerate}
        \item Dimostrare l'esistenza di un programma \(n\) che verifichi la seguente equazione:
        \[
            \varphi_n\rnd{x} = \varphi_x\rnd{\ngle{n, \varphi_x\rnd{1}}}
        \]
        \item Successivamente, chiamato \(\bar{n}\) una soluzione della equazione, si definisce l'insieme:
        \[
            A = \crl{x \mid \varphi_{\bar{n}}\rnd{x} \neq \bot}
        \]
        Si dica a quale classe appartengono \(A\) e \(A^C\)
    \end{enumerate}
\end{problem}
\begin{solution}[Esercizio riassuntivo]
    \begin{multicols}{2}
        Partiamo dal primo punto ed iniziamo con l'osservare la parte destra dell'equazione, applicando l'interprete universale:
        \begin{align*}
            \varphi_x\rnd{\ngle{n, \varphi_x\rnd{1}}} &= \underbrace{\varphi_x\rnd{\ngle{n, \varphi_u\rnd{x,1}}}}_{\text{Sostituisco \(\varphi_x\rnd{i}\) con la funzione universale}}\\
            &= \underbrace{\varphi_u\rnd{x, \ngle{n, \varphi_u\rnd{x,1}}}}_{\text{Sostituisco \(\varphi_x\rnd{\ldots}\) con la funzione universale}}\\
            &= \underbrace{f\rnd{n,x}}_{\text{Diventa quindi una funzione in \(n\) ed \(x\)}}
        \end{align*}
        dove l'ultimo passaggio indica che il risultato ottenuto è una funzione solamente di \(n\) ed \(x\). Inoltre, \(f\rnd{n,x} \in P_f\) poiché è composizione di funzioni ricorsive parziali \(\rnd{\varphi_u}\) e totali (la funzione coppia di Cantor). Quindi esisterà in particolare un programma \(\alpha\) tale che \(\varphi_\alpha\rnd{n,x} = f\rnd{n,x}\). Allora si ha:
        \[
            \varphi_\alpha\rnd{n,x} = \varphi_{S^1_1\rnd{\alpha,n}}\rnd{x}
        \]
        Con \(S^1_1\rnd{\alpha, n} \in T_f\) per ipotesi.
        
        Si noti che \(S^1_1\rnd{\alpha, n}\) è funzione solamente di \(n\) poiché \(\alpha\) è un programma fissato.
        
        Allora possiamo applicare il teorema di ricorsione, in base al quale esiste un \(\bar{n}\) tale che:
        \begin{align*}
            \varphi_{\bar{n}}\rnd{x} &= \underbrace{\varphi_{S^1_1\rnd{\alpha, \bar{n}}}\rnd{x}}_{\text{Per teorema di ricorsione}}\\
            &= \varphi_\alpha\rnd{\bar{n}, x}\\
            &= \varphi_u\rnd{x, \ngle{\bar{n}, \varphi_u\rnd{x,1}}}\\
            &= \varphi_x\rnd{\ngle{\bar{n}, \varphi_x\rnd{1}}}
        \end{align*}
        Ottenendo quindi l'equazione del primo punto.
        \columnbreak
        
        Passiamo ora al secondo punto:
        
        Ora osserviamo che \(A\), così come è definito, non coinvolge gli indici delle funzioni \(\varphi_i\), pertanto lo riscriviamo utilizzando l'equazione sopra descritta (e di cui \(\bar{n}\) è soluzione). Procediamo quindi scrivendo:
        \[
            A = \crl{x\mid \varphi_x\rnd{\ngle{\bar{n}, \varphi_x\rnd{1}}}\neq\bot}
        \]
        Ora, \(A\) rispetta le funzioni per costruzione (essendo costruito come l'insieme su cui la funzione è definita), ed inoltre è immediato verificare che non si tratta né dell'insieme vuoto né di \(\N\) (poiché risulta possibile sia trovare almeno un \(\bar{n}\) per cui \(\exists x: \varphi_{\bar{n}} = \bot\), basta immaginare ad una funzione che con qualsiasi ingresso va in deadlock e quindi l'insieme non può essere \(\N\), sia un \(\bar{n}\) tale per cui \(\exists x:\varphi_{\bar{n}} \neq \bot\), basti immaginare una funzione che ritorna sempre un valore costante e quindi l'insieme non può essere \(\emptyset\).). Applicando il teorema di Rice deduciamo che esso non è certamente ricorsivo, e nemmeno \(A^C\) lo è, dato che la classe degli insiemi ricorsivi è chiusa per complemento.
        
        Volendo controllare se \(A\) è ricorsivamente numerabile, possiamo sfruttare la definizione di insieme ricorsivamente numerabile come dominio di una funzione \(f\in P_f\). Dovremo quindi mostrare che esiste un programma in particolare che, su input \(x\), termina se \(x\in A\), altrimenti va in loop.
        
        In questo caso però risulta molto più comodo mostrare un programma che termina quando \(x \not\in A\), cioè quando \(\varphi_n\rnd{x} = \bot\), mentre va in loop in caso contrario.
        
        Tale programma è facilmente implementato richiamando l'interprete universale \(\varphi_u\rnd{n,x}\), e dimostra che \(A^C\) è ricorsivamente numerabile.
        
        Ne segue che \(A\) non può essere nemmeno ricorsivamente numerabile, poiché se lo fosse si avrebbe che sia \(A\) che \(A^C\) sarebbero ricorsivi, cosa che sappiamo non essere.
    \end{multicols}
\end{solution}

\part{Computabilità}
\chapter{Macchine di Turing deterministiche}

\begin{definition}[Macchina di Turing]
    Una \textbf{macchina di Turing deterministica} ad un nastro è una \(6\)-tupla \(M=\rnd{Q,\Sigma,\Gamma,\delta, q_0, \crl{q_s, q_n}}\) in cui:
    \begin{enumerate}
        \item \(Q\) è un insieme \textbf{finito di stati}
        \item \(\Sigma\) è l'\textbf{alfabeto di input}
        \item \(\Gamma\) è l'\textbf{alfabeto di lavoro}. Vale che \(\Sigma \subset \Gamma\). Esiste in particolare, un simbolo speciale, \textbf{blank}, \(B \in \Gamma\setminus\Sigma\).
        \item \(\funcdef{\delta}{\rnd{Q\setminus\crl{q_s,q_n}}\times\Gamma}{Q\times\rnd{\Gamma\setminus\crl{\text{blank}}}\times\crl{-1,1}}\) è la \textbf{funzione di transizione}
        \item \(q_0 \in Q\) è lo \textbf{stato iniziale}
        \item \(\crl{q_s, q_n}\subseteq Q\) è l'insieme degli \textbf{stati finali}. In particolare, \(q_s\) è detto \textbf{accettante}, mentre \(q_n\) è detto \textbf{non accettante}.
    \end{enumerate}
\end{definition}
\begin{multicols}{2}
    \begin{definition}[Computazione]
        Una sequenza di \textit{mosse} è detta \textbf{computazione di \(M\) su input \(x\)}. Tale computazione può essere finita o infinita, secondo che si giunga o meno ad uno dei due stati finali \(q_s\) e \(q_n\).
    \end{definition}
    \begin{definition}[Computazione accettante]
        La computazione di \(M\) su \(x\) è \textbf{accettante} se termina nello stato \(q_s\). In tal caso, diciamo che \(M\) \textbf{accetta} \(x\).
        
        Se invece la computazione termina nello stato \(q_n\) oppure non termina, diciamo che \(M\) \textbf{non accetta} \(x\).
    \end{definition}
    \begin{definition}[Configurazione]
        Una \textbf{configurazione} di \(M\) è una descrizione, ad ogni dato istante:
        \begin{enumerate}
            \item dello stato assunto dal controllo
            \item dalla posizione della testina sul nastro
            \item dal contenuto del nastro
        \end{enumerate}
        Diciamo che \(M\) si trova nella configurazione \(\ngle{q,k,w}\) se:
        \begin{enumerate}
            \item Il controllo è nello stato \(q\)
            \item La testina è posizionata sulla \(k\)-esima cella del nastro
            \item La porzione non blank del nastro è rappresentata dalla stringa \(w \in \Gamma^*\)
        \end{enumerate}
        Una configurazione può essere denotata da \(uqv\), intendendo cioè che:
        \begin{enumerate}
            \item \(M\) si trova nello stato \(q\)
            \item Il contenuto non blank del nastro di lavoro è la stringa \(uv \in \Gamma^*\)
            \item La testina sta scandendo il primo carattere di \(v\)
        \end{enumerate}
    \end{definition}
    \begin{definition}[Linguaggio accettato]
        Il linguaggio \(L_M\) \textbf{accettato o riconosciuto} da \(M\) è definito come l'\textbf{insieme delle stringhe in \(\Sigma^*\) accettate da \(M\)}. Si tratta dell'insieme:
        \[
            L_M = \crl{x \in \Sigma^* \mid M \text{ accetta }x}
        \]
    \end{definition}
    \begin{definition}[Configurazione iniziale]
        La \textbf{configurazione iniziale} di \(M\) su input \(x\) è data da \(c_0 = \ngle{q_0, 1, x}\) o equivalentemente \(c_0 = q_0x\).
    \end{definition}
    \begin{definition}[Configurazione accettante]
        Data una configurazione \(c\), denotiamo con \(q\rnd{c}\) lo stato contenuto in \(c\). \(c\) è detta \textbf{accettante} (non accettante) se \(q\rnd{c} = q_s\) (\(q\rnd{c} = q_n\)).
    \end{definition}
    \begin{definition}[Configurazione successiva]
        Date due configurazioni \(c'\) e \(c''\), con \(q\rnd{x'} \in \crl{q_s, q_n}\), diciamo  che \(c''\) è la configurazione successiva a \(c'\) (e scriviamo \(c' c''\)) se \(M\) da \(c'\) a \(c''\) in una mossa.
    \end{definition}
    \begin{definition}[Configurazione d'arresto]
        Le configurazioni accettanti e non accettanti non hanno successori e sono, quindi, da ritenersi \textbf{configurazioni d'arresto}.
    \end{definition}
    \begin{observation}[Perché sono deterministiche?]
        L'aggettivo deterministico esprime il fatto che per ogni configurazione di \(M\) esiste al più una configurazione successiva univocamente determinata dalla funzione di transizione di \(M\).
        
    \end{observation}
\end{multicols}
\section{Macchina di Turing e Problemi di Decisione}
\begin{theorem}[Insiemi ricorsivamente numerabili e macchine di Turing]
    Sia \(A\subseteq \N\). Allora \(A\) è ricorsivamente numerabile se e solo se esiste una macchina di Turing deterministica \(M\) tale che \(L_M = L_A\)
    
    La classe degli insiemi ricorsivamente numerabili coincide con la classe degli insiemi riconosciuti da macchine di Turing deterministiche.
    
    In altre parole, una macchina di Turing deterministica può essere vista come una \textbf{procedura} che accetta le stringhe appartenenti ad un insieme ricorsivamente numerabile.
\end{theorem}

\begin{theorem}[Insiemi ricorsivi e macchine di Turing]
    Sia \(A\subseteq \N\). Allora \(A\) è ricorsivo se e solo se esiste un algoritmo deterministico per \(L_A\)
    
    Vale a dire che classe degli insiemi ricorsivi coincide con la classe degli insiemi riconosciuti da algoritmi deterministici.
\end{theorem}
\section{Macchine di Turing per il calcolo di funzioni}
\begin{definition}[Macchina di Turing che calcola funzione parziale]
    Oltre che come riconoscitori di linguaggi, le macchine di Turing deterministiche possono essere viste come dispositivi per il calcolo di funzioni.
    
    Diciamo che la macchina di Turing deterministica \(M\) calcola la funzione parziale \(\funcdef{f}{\Sigma^*}{\Gamma^*}\) se:
    \begin{enumerate}
        \item Su ogni stringa \(x \in \Sigma^*\) su cui \(f\) è definita, la computazione di \(M\) su \(x\) si arresta in una configurazione avente \(f\rnd{x} \in \Gamma^*\) sul nastro di lavoro.
        \item Su ogni stringa \(x \in \Sigma^*\) su cui \(f\) non è definita, la computazione di \(M\) su \(x\) non si arresta.
    \end{enumerate}
\end{definition}
\begin{observation}[Le macchine di Turing sono un sistema di programmazione accettabile]
    È ben noto che le macchine di Turing deterministiche costituiscono un \textbf{sistema di programmazione accettabile}. Infatti:
    \begin{enumerate}
        \item La classe delle funzioni calcolate da macchine di Turing deterministiche coincide con quella delle funzioni \textbf{ricorsive parziali}.
        \item Esiste una macchina di Turing deterministica \textbf{universale}, in grado, cioè, di simulare ogni altra macchina di Turing deterministica.
        \item Vale il \textbf{Teorema \(S^{m}_n\)}
    \end{enumerate}
    Pertanto in tale contesto vale la Tesi di Church per le macchine di Turing.
\end{observation}
\begin{theorem}[Tesi di Church per le macchine di Turing]
    La classe delle funzioni intuitivamente calcolabili coincide con la classe delle funzioni calcolate da macchine di Turing deterministiche.
\end{theorem}
\clearpage
\section{Tempo di calcolo}
\begin{multicols}{2}
\begin{definition}[Complessità del caso pessimo nel tempo]
    Sia \(M\) una macchina di Turing deterministica. La complessità in tempo di \(M\) su input di lunghezza \(n\) è data dalla funzione \(\funcdef{t_M}{\N}{\N}\) tale che:
    \[
        t_M\rnd{n} = \max\crl{T_M\rnd{x}\mid x \in \Sigma^n}
    \]
\end{definition}
\begin{definition}[DTIME]
    Si indica con \(\text{DTIME}\rnd{\f{n}}\) la classe dei linguaggi accettati da macchine di Turing deterministiche in tempo \(O\rnd{\f{n}}\).
\end{definition}
\begin{definition}[Classe dei linguaggi accettati da macchine di Turing]
    Per ogni funzione \(\funcdef{t}{\N}{\N}\), \(\text{DTIME}\rnd{t\rnd{n}}\) è la classe dei linguaggi accettati da macchine di Turing deterministiche in tempo \(t\rnd{n}\).
\end{definition}
\begin{proposition}
    Per ogni funzione \(\funcdef{t}{\N}{\N}\) tale che \(\lim_{n\rightarrow +\infty} \frac{t\rnd{n}}{n} = +\infty\) e per ogni costante \(c>0\), vale:
    \[
        \text{DTIME}\rnd{c\cdot t\rnd{n}} = \text{DTIME}\rnd{t\rnd{n}}
    \]
\end{proposition}
\begin{theorem}[Tesi di Church Estesa]
    Un problema di decisione è effettivamente risolubile se ammette un algoritmo deterministico polinomiale in tempo.
\end{theorem}
\begin{theorem}[Complessità di macchine di Turing a uno e \(k\) nastri]
    Se un linguaggio \(L\) è riconoscibile in tempo \(t\rnd{n}\) da una macchina di Turing deterministica a \(k>1\) nastri, allora \(L\) è riconoscibile da una macchina di Turing deterministica a un nastro in tempo \(O\rnd{t^2\rnd{n}}\)
\end{theorem}
\begin{proof}[Complessità di macchine di Turing a uno e \(k\) nastri]
    Sia \(M\) una macchina di Turing deterministica a \(k\) nastri che riconosce \(L\) in tempo \(t\rnd{n}\) e sia \(\Gamma\) l'alfabeto di lavoro di \(M\). 
    
    Possiamo definire un nuovo alfabeto di lavoro \(\Gamma' = \rnd{\Gamma \times \crl{0,1}}^k\). Così, in maniera del tutto ovvia, una stringa \(x \in \Gamma^{'*}\) può descrivere il contenuto delle porzioni non blank dei \(k\) nastri di \(M\) e la posizione delle corrispondenti testine.
    
    Infatti, se \(x_j = \rnd{\rnd{a_1, l_1}, \ldots, \rnd{a_k, l_k}}\) è la \(j\)-esima lettera di \(x\), allora ogni \(a_i\) è il contenuto della \(j\)-esima cella nel nastro \(i\)-esimo, con \(1\leq i \leq k\), mentre \(l_i = 1\) se e solo se su tale cella è posizionata la relativa testina.
    
    Definiamo ora una nuova macchina di Turing deterministica \(M'\) ad un solo nastro, avente \(\Gamma'\) come alfabeto di lavoro, che simula \(M\). La computazione di \(M'\) su un generico input è suddivisa in fasi, una per ogni mossa della macchina \(M\).
    
    In ogni fase, \(M'\) scorre la porzione non blank del suo nastro dalla prima all'ultima posizione e riporta quindi la testina sulla prima cella. \textbf{Durante questa doppia passata}, la macchina aggiorna opportunamente il contenuto del nastro in modo da simulare un passo di \(M\): nella prima scansione si aggiornano le componenti corrispondenti agli spostamenti delle testine di \(M\) verso destra, mentre nella seconda si aggiornano quelli relativi agli spostamenti verso sinistra.

    Inoltre, al termine di ogni fase, \(M'\) ha memorizzato nello stato il simbolo letto da ciascuna testina di \(M\) in modo da determinare la mossa da simulare nella fase successiva, cioè i nuovi simboli da stampare e gli spostamenti delle testine.
    
    Poiché \(M\) in \(t\rnd{n}\) passi può visitare al più \(t\rnd{n}+1\) celle su ogni nastro, ogni fase di \(M'\) su input di dimensione \(n\) può essere eseguita in al più \(2\cdot t\rnd{n}+1\) passi. Ne segue che il numero totale di mosse compiute da \(M'\) è al più uguale a \(2\cdot t^2\rnd{n} + t\rnd{n}\).
\end{proof}
\end{multicols}
\clearpage
\section{Spazio di lavoro}
\begin{multicols}{2}
\begin{definition}[Spazio di lavoro]
    Lo \textbf{spazio} è inteso come quantità di memoria occupata durante la computazione.
\end{definition}
\begin{definition}[Complessità nello spazio]
    Data la macchina di Turing deterministica \(M = \ngle{Q, \Sigma, \Gamma, \delta, q_0, \crl{q_s, q_n}}\) ed una stringa \(x\in\Sigma^*\), sia \(S\rnd{x}\) il numero di celle diverse dal nastro visitate durante la computazione di \(M\) su \(x\). Poniamo \(S\rnd{x} = +\infty\) se \(M\) visita infinite celle. La \textbf{complessità nello spazio nel caso pessimo} di \(M\) è la funzione \(\funcdef{s}{\N}{\N}\) definita come:
    \[
        s\rnd{n} = \max\crl{S\rnd{x}\mid x \in \Sigma^* \land \abs{x} = n}
    \]
    Diciamo che il linguaggio \(L \subseteq \Sigma^*\) è riconosciuto in spazio \(f\rnd{n}\) se esiste una macchina di Turing deterministica \(M\) tale che:
    \begin{enumerate}
        \item \(L = L_M\)
        \item \(M\) ha complessità in spazio \(s\rnd{n} \leq f\rnd{n}\)
    \end{enumerate}
    La complessità in spazio di \(L\) è la minima complessità in spazio per una macchina di Turing deterministica che accetta \(L\).
\end{definition}
\begin{definition}[DSPACE]
    Si definisce \(\text{DSPACE}\rnd{f\rnd{n}}\) la classe dei linguaggi riconosciuti da macchine di Turing deterministiche (con nastri di input e di lavoro separati) in spazio \(O\rnd{\f{n}}\).
\end{definition}
\begin{proposition}
    Per ogni costante \(c>0\) vale:
    \[
        \text{SPACE}\rnd{c\cdot s\rnd{n}} = \text{DSPACE}\rnd{s\rnd{n}}
    \]    
\end{proposition}
\begin{theorem}[DTIME e DSPACE]
    Per ogni funzione \(\funcdef{f}{\N}{\N}\), vale:
    \[
        \text{DTIME}\rnd{f\rnd{n}} \subseteq \text{DSPACE}\rnd{f\rnd{n}}
    \]
\end{theorem}
\begin{proof}[DTIME e DSPACE]
    È sufficiente osservare che una macchina di Turing deterministica che lavora in tempo \(f\rnd{n}\) può visitare al più \(f\rnd{n}\) celle diverse sul nastro di lavoro, una nuova cella per ogni mossa.
\end{proof}
\end{multicols}
\chapter{La classe NP}
\begin{multicols}{2}
\begin{definition}[SODD]
    Il problema è costituito da:
    \begin{description}
        \item[Istanza:] una formula \(\varphi\rnd{x_1, \ldots, x_n}\)
        \item[Questione:] \(\varphi\) è soddisfacibile? Esiste un assegnamento \(\bma \in \crl{0,1}^n\) tale che \(\varphi\rnd{\bma} = 1\)?
    \end{description}
    Osserviamo che:
    \begin{enumerate}
        \item Se \(\varphi\) è soddisfacibile, allora esiste un assegnamento \(\bma\) che dimostra la soddisfacibile, cioè tale che \(\varphi\rnd{\bma} = 1\). La dimensione \(\abs{\bma}\) del "testimone" \(\bma\) è al più la dimensione \(\abs{\varphi}\) della formula. Inoltre verificare \(\varphi\rnd{\bma} = 1\) dato un \(\bma\) è fattibile in tempo polinomiale \(\abs{\varphi}^{O\rnd{1}}\).
        \item Se \(\varphi\) non è soddisfacibile, allora nessun assegnamento soddisfa \(\varphi\).
    \end{enumerate}
\end{definition}
\begin{definition}[Problema NP]
    Un linguaggio \(L\subseteq \Sigma^*\) è nella classe NP se esiste una relazione \(V\rnd{x,y}\) calcolabile in tempo polinomiale ed un polinomio \(p\rnd{n}\) per cui:
    \[
        L = \crl{x \mid \exists y: \rnd{p\rnd{\abs{x}}} \land \rnd{V\rnd{x,y}=1}}
    \]
    Vale cioè che:
    \begin{enumerate}
        \item Se \(x \in L\) allora esiste una "breve" dimostrazione di appartenenza \(y\), cioè \(\abs{y} = p\rnd{\abs{x}}\) e \(V\rnd{x,y} = 1\). Inoltre il calcolo \(V\rnd{x,y}\) può essere fatto in tempo polinomiale.
        \item Se \(x \not\in L\) allora non esiste alcuna dimostrazione di lunghezza \(p\rnd{\abs{x}}\), cioè se \(\abs{y} = p\rnd{\abs{x}}\) allora \(V\rnd{x,y}=0\)
    \end{enumerate}
\end{definition}
\end{multicols}
\section{Classificazione dei problemi: concetto di riduzione} 
\begin{multicols}{2}
\begin{definition}[Riduzione polinomiale multi-uno]
    Dati due linguaggi \(L_1, L_2 \subseteq \Sigma^*\) diremo che \(L_1\) è \textbf{polinomialmente riducibile multi-uno} a \(L_2\) se esiste una funzione \(\funcdef{f}{\Sigma^*}{\Sigma^*}\) tale che:
    \begin{enumerate}
        \item \(f\) è calcolabile in tempo polinomiale.
        \item \(x \in L_1\) se e solo se \(f\rnd{x} \in L_2\)
    \end{enumerate}
    Scriveremo in tal caso \(L_1 <_p L_2\). Se ulteriormente \(f\) è calcolabile in spazio logaritmico, diremo che \(L_1\) è \textbf{riducibile multi-uno in spazio logaritmico} a \(L_2\) scrivendo \(L_1 <_l L_2\).
\end{definition}
\begin{theorem}
    Dati due linguaggi \(L_1, L_2 \subseteq \Sigma^*\), allora:
    \begin{enumerate}
        \item se \(L_1 <_p L_2\) e \(L_2 \in \text{P}\) allora \(L_1 \in \text{P}\)
        \item se \(L_1 <_l L_2\) e \(L_2 \in \text{NC}\) allora \(L_1 \in \text{NC}\)
    \end{enumerate}
    Dove \(NC\) è la classe dei problemi efficientemente risolubili con algoritmi paralleli.
\end{theorem}
\end{multicols}
\clearpage
\section{Problemi P-completi e NP-Completi}
\begin{multicols}{2}
\begin{definition}[P-Completo]
    Un problema \(A\) è detto \textbf{P-completo} se:
    \begin{enumerate}
        \item \(A \in \text{P}\)
        \item \(\forall X \in \text{P} \rnd{X <_l A}\)
    \end{enumerate}
\end{definition}
\begin{definition}[NP-Completo]
    Un problema \(B\) è detto \textbf{NP-completo} se:
    \begin{enumerate}
        \item \(B \in \text{NP}\)
        \item \(\forall X \in \text{NP} \rnd{X <_p B}\)
    \end{enumerate}
\end{definition}
\begin{theorem}
    Dati due problemi \(A\) e \(B\), allora:
    \begin{enumerate}
        \item Se \(A\) è \(P\)-completo e \(A \in NC\), allora \(NC = P\).
        \item Se \(B\) è \(NP\)-completo e \(B \in P\), allora \(P = NP\) 
    \end{enumerate}
\end{theorem}
\end{multicols}
%\begin{proof}
%   Sia \(X\) un qualsiasi problema in \(NC\). Poiché \(A\) è \(P\)-completo, allora \(X<_l A\) e, poiché \(A \in \text{NC}\), allora per il teorema \ref{}
%\end{proof}

\part{Note in preparazione all'esame}
\chapter{Lista dei teoremi}
\section{Computabilità}
\begin{multicols}{2}
\begin{description}
    \item[Teorema di Cantor] L'insieme \(\N^\N\) non è numerabile.
    \item[Funzioni coppia di Cantor] Si tratta del teorema che illustra l'esistenza di una funzione tra \(\N\) ed \(\N\times\N\), che sono le funzioni coppia.
    \item[Correttezza del compilatore] Viene costruita una traduzione tra linguaggio while e RAM e viene mostrato che questa è valida per ogni programma.
    \item[Conseguenza di correttezza del compilatore] Mostra che il set delle funzioni realizzabili in linguaggio while è compatibile anche con il linguaggio RAM.
    \item[Interprete e funzione universale] Introduce il concetto di codifica di un programma, di interprete, e di funzione che simula un formalismo usando le istruzioni di una codifica: la funzione universale.
    \item[Da programma RAM a While] Il teorema mostra che è possibile costruire, per ogni programma RAM, un programma While che svolge la stessa funzione.
    \item[Funzioni ricorsive parziali e programmi while] Mostra che l'insieme delle funzioni ricorsive parziali è computabile da programmi while.
    \item[Da programmi while a funzioni ricorsive parziali] Mostra che l'insieme dei comandi while coincide con una funzione ricorsiva parziale.
    \item[Equivalenza tra insiemi di funzioni] Mostra che tutti gli insiemi di funzioni sono riconducibili alle funzioni ricorsive parziali.
    \item[Tesi di Church] La classe delle funzioni intuitivamente calcolabili è la classe delle funzioni ricorsive parziali.
    \item[Problema dell'arresto] Illustra come il problema dell'arresto non sia decidibile.
    \item[Teorema \(S^1_1\)] Significa che dato un programma \(P\) che lavora su due variabili, è sempre possibile generare automaticamente un programma \(P'\) che lavora su una variabile fissando l'altra.
    \item[Teorema di Ricorsione] Fissato un sistema di programmazione accettabile, per qualsiasi funzione ricorsiva totale \(t\) esiste un programma la cui semantica non cambia sotto \(t\). 
    \item[Insieme ricorsivamente enumerabile] Un insieme ricorsivamente enumerabile è il dominio di una funzione ricorsiva parziale ed è definibile tramite una relazione ricorsiva.
    \item[Teorema di Rice] Il teorema stabilisce che un insieme che rispetta le funzioni è ricorsivo solamente in casi banali: non risulta possibile dimostrare in modo automatico la correttezza dei programmi.
\end{description}
\end{multicols}
\section{Computabilità}
\begin{multicols}{2}
\begin{description}
    \item[Definizione di una macchina di Turing] As title.
    \item[Insiemi ricorsivamente numerabili e macchine di Turing]
    \item[Insiemi ricorsivi e macchine di Turing]
    \item[Tesi di Church per le macchine di Turing] La classe delle funzioni intuitivamente calcolabili coincide con la classe delle funzioni calcolate da macchine di Turing deterministiche.
    \item[Tesi di Church Estesa] Un problema di decisione è effettivamente risolubile se ammette un algoritmo deterministico polinomiale in tempo.
    \item[Complessità di macchine di Turing a uno e \(k\) nastri] Illustra la relazione tra la complessità delle macchine di Turing a uno e quelle a \(k\) nastri.
\end{description}
\end{multicols}

\end{document}